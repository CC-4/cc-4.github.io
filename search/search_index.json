{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Compiladores \u00b6 Requisitos \u00b6 Tener claros los conceptos de CC1, CC2 y CC3. Tener claros los conceptos de Inform\u00e1tica 3. Tener habilidad para programar en Java. Descripci\u00f3n \u00b6 Este es un curso introductorio al dise\u00f1o de lenguajes de programaci\u00f3n y a la implementaci\u00f3n de sus compiladores e int\u00e9rpretes. En el proceso, haremos una exploraci\u00f3n general al dise\u00f1o de lenguajes de programaci\u00f3n y su impacto en la implementaci\u00f3n de los mismos. Durante este semestre, nos enfocaremos en un lenguaje particular: Classroom Object Oriented Language ( COOL ). Objetivos \u00b6 Uno de los objetivos de este curso es explorar la estructura de los lenguajes de programaci\u00f3n y considerar alternativas a caracter\u00edsticas familiares en lenguajes de programaci\u00f3n. Estudiaremos adem\u00e1s el problema de la traducci\u00f3n de lenguajes de alto nivel a formas que pueda ejecutar la m\u00e1quina, utilizando el lenguaje COOL como lenguaje de alto nivel y RISC-V como lenguaje ensamblador. La implementaci\u00f3n de un compilador se hace por varias razones: Aprender t\u00e9cnicas que se aplican a muchas clases de problemas fuera del \u00e1mbito de un compilador, Obtener una mejor comprensi\u00f3n de las herramientas que utilizamos cuando programamos y los costos de los programas que escribimos. Para obtener experiencia construyendo y validando un problema de ingenier\u00eda sustancialmente complejo. Libro de Texto \u00b6","title":"Inicio"},{"location":"#compiladores","text":"","title":"Compiladores"},{"location":"#requisitos","text":"Tener claros los conceptos de CC1, CC2 y CC3. Tener claros los conceptos de Inform\u00e1tica 3. Tener habilidad para programar en Java.","title":"Requisitos"},{"location":"#descripcion","text":"Este es un curso introductorio al dise\u00f1o de lenguajes de programaci\u00f3n y a la implementaci\u00f3n de sus compiladores e int\u00e9rpretes. En el proceso, haremos una exploraci\u00f3n general al dise\u00f1o de lenguajes de programaci\u00f3n y su impacto en la implementaci\u00f3n de los mismos. Durante este semestre, nos enfocaremos en un lenguaje particular: Classroom Object Oriented Language ( COOL ).","title":"Descripci\u00f3n"},{"location":"#objetivos","text":"Uno de los objetivos de este curso es explorar la estructura de los lenguajes de programaci\u00f3n y considerar alternativas a caracter\u00edsticas familiares en lenguajes de programaci\u00f3n. Estudiaremos adem\u00e1s el problema de la traducci\u00f3n de lenguajes de alto nivel a formas que pueda ejecutar la m\u00e1quina, utilizando el lenguaje COOL como lenguaje de alto nivel y RISC-V como lenguaje ensamblador. La implementaci\u00f3n de un compilador se hace por varias razones: Aprender t\u00e9cnicas que se aplican a muchas clases de problemas fuera del \u00e1mbito de un compilador, Obtener una mejor comprensi\u00f3n de las herramientas que utilizamos cuando programamos y los costos de los programas que escribimos. Para obtener experiencia construyendo y validando un problema de ingenier\u00eda sustancialmente complejo.","title":"Objetivos"},{"location":"#libro-de-texto","text":"","title":"Libro de Texto"},{"location":"labs/lab00/","text":"Lab 0 (Java) \u00b6 En este laboratorio practicaremos estructuras de datos en Java. Este laboratorio ser\u00e1 revisado manualmente para ver que tal programa, por favor agregue suficientes comentarios para que su c\u00f3digo sea f\u00e1cil de entender. Archivos base \u00b6 Acepte el siguiente repositorio para acceder a los archivos base. https://classroom.github.com/a/3ck4n3fG 1. Categories \u00b6 Implemente en Java la clase Categories seg\u00fan la siguiente descripci\u00f3n. Campos \u00b6 Una hashtable llamada three . Esta tabla se inicializa vac\u00eda cuando llamamos al constructor de la clase, y es encapsulada. La tabla contendr\u00e1 listas encadenadas que a su vez contendr\u00e1n cadenas de caracteres. Un entero llamado counter . Nos indicar\u00e1 cu\u00e1ntos elementos se han logrado guardar en la tabla. M\u00e9todos \u00b6 Un constructor que no recibe argumentos. Se encarga de inicializar a three como una tabla vac\u00eda y a counter como cero. void classify(String input) recibe una cadena de caracteres, y utilizando expresiones regulares de Java, la identificar\u00e1 en una de las siguientes categor\u00edas Correo luiscu@galileo.edu aiken@cs.stanford.edu sysadmin@banco.com.gt Tel\u00e9fono +502 5585 2133 5979-5503 Fecha 27/03/1993 09-07-2024 Considere \u00fanicamente los formatos mostrados en los ejemplos anteriores, no se complique con formatos adicionales. Tras identificar a qu\u00e9 categor\u00eda perteneces la cadena, debe guardarla en el lugar correspondiente de la tabla three y actualizar el contador. La tabla three tendr\u00e1 \u00fanicamente tres posibles llaves: mail , phone y date . Cada una de estas llaves nos servir\u00e1 para identificar una lista encadenada donde guardaremos las cadenas. Si es la primera vez que se est\u00e1 ingresando un dato de cierto tipo, en ese momento se debe crear la lista e ingresar el dato. Si la lista ya existe, el nuevo dato se agrega al final de esta. Si el dato ingresado no corresponde a alguno de los tres tipos, ign\u00f3relo. void printMails() imprime en pantalla de forma ordenada las direcciones de correo almacenadas en la tabla. Si no hay ninguna guardada, imprime \"NO MAILS\". void printPhones() imprime en pantalla de forma ordenada los n\u00fameros telef\u00f3nicos guardados en la tabla. Si no hay ninguno guardado, imprime \"NO PHONES\". void printDates() imprime a pantalla de forma ordenada las fechas contenidas en la tabla. Si no hay ninguna guardada, imprime \"NO DATES\". void countByCategory() imprime a pantalla de forma ordenada cu\u00e1ntos datos de cada tipo est\u00e1n guardados (no los valores). Al completar la clase anterior, implemente la clase CategoryUserInterface . Esta clase tiene un main el cu\u00e1l usar\u00e1 para probar la clase anterior. En el main hay un ciclo que le pide al usuario ingresar una cadena, esta ser\u00e1 enviada al m\u00e9todo classify de la clase anterior para que sea guardado en la tabla. Tras ingresar exitosamente ocho datos a la tabla, use countByCategory para desplegar cu\u00e1ntos se ingresaron de cada tipo. Luego use los prints que se crearon para desplegar el contenido de la tabla de forma ordenada. Podemos visualizar la tabla de esta manera: 2. BinaryTree \u00b6 Implemente la clase BinaryTree que represente un \u00e1rbol binario, implemente tambi\u00e9n cualquier otra clase que pueda necesitar para el \u00e1rbol. Este \u00e1rbol debe ser capaz de guardar enteros. Agregue los m\u00e9todos necesarios para poder agregar elementos al \u00e1rbol, y desde su clase BinaryTreeMain construya el siguiente \u00e1rbol: Agregue un m\u00e9todo para que su \u00e1rbol se pueda desplegar de forma de recursiva, y que al hacerlo los n\u00fameros queden en el siguiente orden: 31, 44, 47, 48, 64, 65, 67, 74, 76, 78 Entrega \u00b6 Haga add + commit + push de sus archivos. Env\u00ede en el GES el link de su repositorio.","title":"0: Java"},{"location":"labs/lab00/#lab-0-40java41","text":"En este laboratorio practicaremos estructuras de datos en Java. Este laboratorio ser\u00e1 revisado manualmente para ver que tal programa, por favor agregue suficientes comentarios para que su c\u00f3digo sea f\u00e1cil de entender.","title":"Lab 0 (Java)"},{"location":"labs/lab00/#archivos-base","text":"Acepte el siguiente repositorio para acceder a los archivos base. https://classroom.github.com/a/3ck4n3fG","title":"Archivos base"},{"location":"labs/lab00/#1-categories","text":"Implemente en Java la clase Categories seg\u00fan la siguiente descripci\u00f3n.","title":"1. Categories"},{"location":"labs/lab00/#campos","text":"Una hashtable llamada three . Esta tabla se inicializa vac\u00eda cuando llamamos al constructor de la clase, y es encapsulada. La tabla contendr\u00e1 listas encadenadas que a su vez contendr\u00e1n cadenas de caracteres. Un entero llamado counter . Nos indicar\u00e1 cu\u00e1ntos elementos se han logrado guardar en la tabla.","title":"Campos"},{"location":"labs/lab00/#metodos","text":"Un constructor que no recibe argumentos. Se encarga de inicializar a three como una tabla vac\u00eda y a counter como cero. void classify(String input) recibe una cadena de caracteres, y utilizando expresiones regulares de Java, la identificar\u00e1 en una de las siguientes categor\u00edas Correo luiscu@galileo.edu aiken@cs.stanford.edu sysadmin@banco.com.gt Tel\u00e9fono +502 5585 2133 5979-5503 Fecha 27/03/1993 09-07-2024 Considere \u00fanicamente los formatos mostrados en los ejemplos anteriores, no se complique con formatos adicionales. Tras identificar a qu\u00e9 categor\u00eda perteneces la cadena, debe guardarla en el lugar correspondiente de la tabla three y actualizar el contador. La tabla three tendr\u00e1 \u00fanicamente tres posibles llaves: mail , phone y date . Cada una de estas llaves nos servir\u00e1 para identificar una lista encadenada donde guardaremos las cadenas. Si es la primera vez que se est\u00e1 ingresando un dato de cierto tipo, en ese momento se debe crear la lista e ingresar el dato. Si la lista ya existe, el nuevo dato se agrega al final de esta. Si el dato ingresado no corresponde a alguno de los tres tipos, ign\u00f3relo. void printMails() imprime en pantalla de forma ordenada las direcciones de correo almacenadas en la tabla. Si no hay ninguna guardada, imprime \"NO MAILS\". void printPhones() imprime en pantalla de forma ordenada los n\u00fameros telef\u00f3nicos guardados en la tabla. Si no hay ninguno guardado, imprime \"NO PHONES\". void printDates() imprime a pantalla de forma ordenada las fechas contenidas en la tabla. Si no hay ninguna guardada, imprime \"NO DATES\". void countByCategory() imprime a pantalla de forma ordenada cu\u00e1ntos datos de cada tipo est\u00e1n guardados (no los valores). Al completar la clase anterior, implemente la clase CategoryUserInterface . Esta clase tiene un main el cu\u00e1l usar\u00e1 para probar la clase anterior. En el main hay un ciclo que le pide al usuario ingresar una cadena, esta ser\u00e1 enviada al m\u00e9todo classify de la clase anterior para que sea guardado en la tabla. Tras ingresar exitosamente ocho datos a la tabla, use countByCategory para desplegar cu\u00e1ntos se ingresaron de cada tipo. Luego use los prints que se crearon para desplegar el contenido de la tabla de forma ordenada. Podemos visualizar la tabla de esta manera:","title":"M\u00e9todos"},{"location":"labs/lab00/#2-binarytree","text":"Implemente la clase BinaryTree que represente un \u00e1rbol binario, implemente tambi\u00e9n cualquier otra clase que pueda necesitar para el \u00e1rbol. Este \u00e1rbol debe ser capaz de guardar enteros. Agregue los m\u00e9todos necesarios para poder agregar elementos al \u00e1rbol, y desde su clase BinaryTreeMain construya el siguiente \u00e1rbol: Agregue un m\u00e9todo para que su \u00e1rbol se pueda desplegar de forma de recursiva, y que al hacerlo los n\u00fameros queden en el siguiente orden: 31, 44, 47, 48, 64, 65, 67, 74, 76, 78","title":"2. BinaryTree"},{"location":"labs/lab00/#entrega","text":"Haga add + commit + push de sus archivos. Env\u00ede en el GES el link de su repositorio.","title":"Entrega"},{"location":"labs/lab01/","text":"Lab 1 (COOL) \u00b6 Para este lab, deben hacer los ejercicios que se les pide a continuaci\u00f3n, estos ejercicios son bastante b\u00e1sicos y est\u00e1n con el \u00fanico prop\u00f3sito de que ustedes sepan qu\u00e9 se puede hacer en el lenguaje COOL. Este lab ser\u00e1 la \u00fanica vez en que sea necesario programar en COOL, pero no significa que luego pueda olvidar el lenguaje, ya que para los proyectos es necesario que ustedes sean capaces de crear sus propios archivos de pruebas para probar sus implementaciones. Archivos base \u00b6 Acepte el siguiente repositorio para acceder a los archivos base. https://classroom.github.com/a/z40kaGWQ 1. Hola Mundo \u00b6 Cree un archivo llamado hello.cl e imprima \"Hola mundo\" en consola. Esto ya lo tenemos en alg\u00fan ejemplo, escr\u00edbalo sin consultar esos archivos. 2. IO \u00b6 En un archivo llamado io.cl , escriban un programa en COOL que pregunte al usuario su nombre, luego su edad, luego que despliegue el nombre de la persona y cuantos a\u00f1os tendr\u00e1 al graduarse. (Sean optimistas, no le sumen tantos a\u00f1os a la edad actual). Su programa debe de funcionar de la siguiente manera: Ingrese su nombre: Timmy Ingrese su edad: 19 Timmy tendr\u00e1 22 a\u00f1os al graduarse : ) 3. M\u00e9todos \u00b6 En un archivo llamado methods.cl , hagan un programa que le pida al usuario un n\u00famero en grados Celsius y los convierta en Fahrenheit. Ustedes tiene que crear un m\u00e9todo llamado toFahrenheit que efect\u00fae esta conversi\u00f3n: toFahrenheit ( x : Int ): Int { // su codigo aqui }; Su programa debe de funcionar de la siguiente manera: Ingrese grados Celsius: 32 32 Celsius son 89 Fahrenheit Punto flotante COOL no tiene punto flotante, por lo tanto su implementaci\u00f3n no tiene que ser exacta. Por ejemplo el usuario ingresa 32 Celsius, su salida puede ser 89 Fahrenheit a pesar de que la respuesta exacta es 89.6 4. Ciclos \u00b6 En un archivo llamado loop.cl , escriban un programa que despliegue una tabla de conversion de -50 a 150 grados Celsius hacia grados Fahrenheit en incrementos de 10. Para este ejercico es obligatorio que utilicen un while . Su programa debe de producir el siguiente resultado: -50 Celsius son -58 Fahrenheit -40 Celsius son -40 Fahrenheit -30 Celsius son -22 Fahrenheit -20 Celsius son -4 Fahrenheit -10 Celsius son 14 Fahrenheit 0 Celsius son 32 Fahrenheit 10 Celsius son 50 Fahrenheit 20 Celsius son 68 Fahrenheit 30 Celsius son 86 Fahrenheit 40 Celsius son 104 Fahrenheit 50 Celsius son 122 Fahrenheit 60 Celsius son 140 Fahrenheit 70 Celsius son 158 Fahrenheit 80 Celsius son 176 Fahrenheit 90 Celsius son 194 Fahrenheit 100 Celsius son 212 Fahrenheit 5. Strings \u00b6 En un archivo llamado str.cl , escriban un programa que le pida al usuario 2 Strings y verifiquen si el segundo String est\u00e1 contenido en el primero. Su programa debe de funcionar de la siguiente manera: Ingrese String 1 : Anita lava la tina. Ingrese String 2 : lava lava est\u00e1 contenido en Anita lava la tina. Ingrese String 1 : Anita lava la tina. Ingrese String 2 : shampoo shampoo no est\u00e1 contenido en Anita lava la tina. Recomendaci\u00f3n En el manual de referencia de COOL hay algo que podr\u00eda ayudarnos, p\u00e1gina n\u00famero 14, en espec\u00edfico el m\u00e9todo: substr(i : Int, l : Int) .","title":"1: COOL"},{"location":"labs/lab01/#lab-1-40cool41","text":"Para este lab, deben hacer los ejercicios que se les pide a continuaci\u00f3n, estos ejercicios son bastante b\u00e1sicos y est\u00e1n con el \u00fanico prop\u00f3sito de que ustedes sepan qu\u00e9 se puede hacer en el lenguaje COOL. Este lab ser\u00e1 la \u00fanica vez en que sea necesario programar en COOL, pero no significa que luego pueda olvidar el lenguaje, ya que para los proyectos es necesario que ustedes sean capaces de crear sus propios archivos de pruebas para probar sus implementaciones.","title":"Lab 1 (COOL)"},{"location":"labs/lab01/#archivos-base","text":"Acepte el siguiente repositorio para acceder a los archivos base. https://classroom.github.com/a/z40kaGWQ","title":"Archivos base"},{"location":"labs/lab01/#1-hola-mundo","text":"Cree un archivo llamado hello.cl e imprima \"Hola mundo\" en consola. Esto ya lo tenemos en alg\u00fan ejemplo, escr\u00edbalo sin consultar esos archivos.","title":"1. Hola Mundo"},{"location":"labs/lab01/#2-io","text":"En un archivo llamado io.cl , escriban un programa en COOL que pregunte al usuario su nombre, luego su edad, luego que despliegue el nombre de la persona y cuantos a\u00f1os tendr\u00e1 al graduarse. (Sean optimistas, no le sumen tantos a\u00f1os a la edad actual). Su programa debe de funcionar de la siguiente manera: Ingrese su nombre: Timmy Ingrese su edad: 19 Timmy tendr\u00e1 22 a\u00f1os al graduarse : )","title":"2. IO"},{"location":"labs/lab01/#3-metodos","text":"En un archivo llamado methods.cl , hagan un programa que le pida al usuario un n\u00famero en grados Celsius y los convierta en Fahrenheit. Ustedes tiene que crear un m\u00e9todo llamado toFahrenheit que efect\u00fae esta conversi\u00f3n: toFahrenheit ( x : Int ): Int { // su codigo aqui }; Su programa debe de funcionar de la siguiente manera: Ingrese grados Celsius: 32 32 Celsius son 89 Fahrenheit Punto flotante COOL no tiene punto flotante, por lo tanto su implementaci\u00f3n no tiene que ser exacta. Por ejemplo el usuario ingresa 32 Celsius, su salida puede ser 89 Fahrenheit a pesar de que la respuesta exacta es 89.6","title":"3. M\u00e9todos"},{"location":"labs/lab01/#4-ciclos","text":"En un archivo llamado loop.cl , escriban un programa que despliegue una tabla de conversion de -50 a 150 grados Celsius hacia grados Fahrenheit en incrementos de 10. Para este ejercico es obligatorio que utilicen un while . Su programa debe de producir el siguiente resultado: -50 Celsius son -58 Fahrenheit -40 Celsius son -40 Fahrenheit -30 Celsius son -22 Fahrenheit -20 Celsius son -4 Fahrenheit -10 Celsius son 14 Fahrenheit 0 Celsius son 32 Fahrenheit 10 Celsius son 50 Fahrenheit 20 Celsius son 68 Fahrenheit 30 Celsius son 86 Fahrenheit 40 Celsius son 104 Fahrenheit 50 Celsius son 122 Fahrenheit 60 Celsius son 140 Fahrenheit 70 Celsius son 158 Fahrenheit 80 Celsius son 176 Fahrenheit 90 Celsius son 194 Fahrenheit 100 Celsius son 212 Fahrenheit","title":"4. Ciclos"},{"location":"labs/lab01/#5-strings","text":"En un archivo llamado str.cl , escriban un programa que le pida al usuario 2 Strings y verifiquen si el segundo String est\u00e1 contenido en el primero. Su programa debe de funcionar de la siguiente manera: Ingrese String 1 : Anita lava la tina. Ingrese String 2 : lava lava est\u00e1 contenido en Anita lava la tina. Ingrese String 1 : Anita lava la tina. Ingrese String 2 : shampoo shampoo no est\u00e1 contenido en Anita lava la tina. Recomendaci\u00f3n En el manual de referencia de COOL hay algo que podr\u00eda ayudarnos, p\u00e1gina n\u00famero 14, en espec\u00edfico el m\u00e9todo: substr(i : Int, l : Int) .","title":"5. Strings"},{"location":"labs/lab02/","text":"Lab 2 (Lexer) \u00b6 En este lab implementar\u00e1n la primera fase de un compilador, un analizador l\u00e9xico, para una version sin objetos de COOL. Lo llamaremos CNOOL Classroom Not Object Oriented Language . Un analizador l\u00e9xico conforma la primer parte de un compilador. La funci\u00f3n principal de un analizador l\u00e9xico es tomar una cadena de caracteres y separarla en tokens. Cada uno de estos tokens representa un s\u00edmbolo del lenguaje de programaci\u00f3n. Con el objetivo de ayudarlos en su proyecto, a lo largo de los labs implementaremos fases del proyecto en lenguajes m\u00e1s simples, como ahorita con CNOOL dejando de lado los objetos y los comentarios y diciendo que \u00fanicamente existen tres tipos b\u00e1sicos: String, Int y Bool. Los tokens que debe implementar son los siguientes: PLUS MINUS MULT DIV NEG LT LE EQ NOT TYPEID OBJECTID ASSIGN LPAREN RPAREN LBRACE RBRACE SEMI COMMA COLON INT_CONST BOOL_CONST Si implementa correctamente los tokens anteriores, podr\u00e1 escribir cualquier expresi\u00f3n que aparezca en esta gram\u00e1tica a la que llamaremos CNOOL: program :: = [ feature ] + feature :: = ID ([ formal [ ,formal ] * ]) : TYPE { expr } ; formal :: = ID : TYPE expr :: = ID <- expr | ID ([ expr [ ,expr ] * ]) | ID : TYPE [ <- expr ] | {[ expr ; ] + } | expr + expr | expr - expr | expr * expr | expr / expr | ~ expr | expr < expr | expr < = expr | expr = expr | not expr | ( expr ) | ID | integer | string | true | false Los archivos necesarios para este laboratorio ya los tiene en su m\u00e1quina, son los mismos que usaremos para el proyecto 1. Para obtenerlos ejecute esta instrucci\u00f3n adentro de la carpeta donde trabajar\u00e1: make -f /usr/class/cc4/assignments/PA1/Makefile De todos los archivos que se copiar\u00e1n, \u00fanicamente deben de modificar cool.lex , y agregar las expresiones regulares necesarias para que se generen los tokens indicados. Puede leer pero no modificar el archivo TokenConstants.java , que contiene todos los tokens necesarios para el proyecto. Recuerde que para facilitar la implementaci\u00f3n de este laboratorio, retiraremos los comentarios y los strings. Referencias \u00b6 JLex Manual - Manual de JLex.","title":"2: jLex"},{"location":"labs/lab02/#lab-2-40lexer41","text":"En este lab implementar\u00e1n la primera fase de un compilador, un analizador l\u00e9xico, para una version sin objetos de COOL. Lo llamaremos CNOOL Classroom Not Object Oriented Language . Un analizador l\u00e9xico conforma la primer parte de un compilador. La funci\u00f3n principal de un analizador l\u00e9xico es tomar una cadena de caracteres y separarla en tokens. Cada uno de estos tokens representa un s\u00edmbolo del lenguaje de programaci\u00f3n. Con el objetivo de ayudarlos en su proyecto, a lo largo de los labs implementaremos fases del proyecto en lenguajes m\u00e1s simples, como ahorita con CNOOL dejando de lado los objetos y los comentarios y diciendo que \u00fanicamente existen tres tipos b\u00e1sicos: String, Int y Bool. Los tokens que debe implementar son los siguientes: PLUS MINUS MULT DIV NEG LT LE EQ NOT TYPEID OBJECTID ASSIGN LPAREN RPAREN LBRACE RBRACE SEMI COMMA COLON INT_CONST BOOL_CONST Si implementa correctamente los tokens anteriores, podr\u00e1 escribir cualquier expresi\u00f3n que aparezca en esta gram\u00e1tica a la que llamaremos CNOOL: program :: = [ feature ] + feature :: = ID ([ formal [ ,formal ] * ]) : TYPE { expr } ; formal :: = ID : TYPE expr :: = ID <- expr | ID ([ expr [ ,expr ] * ]) | ID : TYPE [ <- expr ] | {[ expr ; ] + } | expr + expr | expr - expr | expr * expr | expr / expr | ~ expr | expr < expr | expr < = expr | expr = expr | not expr | ( expr ) | ID | integer | string | true | false Los archivos necesarios para este laboratorio ya los tiene en su m\u00e1quina, son los mismos que usaremos para el proyecto 1. Para obtenerlos ejecute esta instrucci\u00f3n adentro de la carpeta donde trabajar\u00e1: make -f /usr/class/cc4/assignments/PA1/Makefile De todos los archivos que se copiar\u00e1n, \u00fanicamente deben de modificar cool.lex , y agregar las expresiones regulares necesarias para que se generen los tokens indicados. Puede leer pero no modificar el archivo TokenConstants.java , que contiene todos los tokens necesarios para el proyecto. Recuerde que para facilitar la implementaci\u00f3n de este laboratorio, retiraremos los comentarios y los strings.","title":"Lab 2 (Lexer)"},{"location":"labs/lab02/#referencias","text":"JLex Manual - Manual de JLex.","title":"Referencias"},{"location":"labs/lab03/","text":"Lab 3 (RDP) \u00b6 En este laboratorio aprender\u00e1n a implementar un Recursive Descent Parser para una gram\u00e1tica simple. 1. Introducci\u00f3n \u00b6 En las \u00faltimas clases ustedes vieron el tema de Recursive Descent Parsing (RDP para simplificar) , aprendieron que es un tipo de parser predictivo y que entra en la categor\u00eda de top-down parsing. Tambi\u00e9n vieron de forma general un algoritmo para implementarlo y en este laboratorio lo pondremos en pr\u00e1ctica. Como el nombre sugiere, un Recursive Descent Parser usa funciones recursivas para implementar un parser predictivo. La idea central es que cada no terminal en la gram\u00e1tica es representado por una de esas funciones recursivas. Cada funci\u00f3n entonces mira el siguiente token (1 token de lookahead) para poder escoger as\u00ed, una de las producciones de alg\u00fan no-terminal . De esta manera es como vamos analizando la entrada y construyendo nuestro \u00e1rbol (si es que la entrada tiene una sint\u00e1xis correcta, de lo contrario desplegar\u00edamos alg\u00fan error). Recuerden que : Un analizador l\u00e9xico (lexer) convierte texto (raw-text) en un stream de tokens. Un analizador sint\u00e1ctico (parser) convierte el stream de tokens en un AST. De forma gr\u00e1fica esos 2 pasos los podemos ver asi: En este laboratorio realizaremos una calculadora con un par de operaciones e iremos un paso m\u00e1s adelante al implementar un int\u00e9rprete , es decir no crearemos un \u00e1rbol sint\u00e1ctico sino que evaluaremos en el momento las expresiones. 2. Gram\u00e1tica \u00b6 La gram\u00e1tica con la que trabajaremos es la siguiente: S :: = E ; E :: = E + E | E - E | E * E | E / E | E % E | E ^ E | - E | ( E ) | number # number en nuestro caso significara un double Esta gram\u00e1tica tiene un gran problema para nuestro RDP. Si se recuerdan por lo visto en clase, sufre de un problema llamado left-recursion . Una de las desventajas de este tipo de parsers es que las gram\u00e1ticas con las que puede trabajar son aquellas que no son recursivas hacia la izquierda y claramente esta lo es, E ::= E + E por ejemplo. As\u00ed que lo que necesitamos hacer primero es transformar nuestra gram\u00e1tica para que no tenga este problema, teniendo en cuenta siempre que el lenguaje que describe nuestra nueva gramatica G1 es el mismo que describe nuestra gram\u00e1tica G original, es decir: $$L(G1) = L(G)$$ 3. Lexer \u00b6 Para el primer ejercicio de este laboratorio, ustedes van a implementar el lexer para la gram\u00e1tica de nuestra calculadora utilizando JLex . El motivo principal de esto es para que sigan ganando pr\u00e1ctica con esta herramienta, que surgan dudas y que los ayude a empezar/avanzar con el proyecto. Para empezar clonen el siguiente repositorio de Github Classroom: https://classroom.github.com/a/EsfgDA-Z Dentro del repositorio van a encontrar un archivo llamado lexer.lex , en ese archivo ustedes tienen que definir el lexer para la gram\u00e1tica. Dentro de ese archivo hay en forma de comentarios algunas instrucciones para guiarlos. 3.1 Clase Token \u00b6 En el directorio de trabajo hay una clase llamada Token que nos va a servir para representar los tokens de la gram\u00e1tica y es el tipo de objeto que tenemos que devolver dentro de las acciones del lexer. Esta clase tiene 2 constructores: Token(int id, String val) Token(int id) Dentro de esta clase tambi\u00e9n est\u00e1n definidos los IDs que representan cada token y tienen que hacer uso de ellos cuando encuentren un token. En ese archivo tambi\u00e9n est\u00e1n definidos otros m\u00e9todos que pueden ser \u00fatiles para la siguiente parte del laboratorio. Ejemplo: // Asi se veria en la parte de acciones del archivo .lex < YYINITIAL >{ SEMI } { return new Token ( Token . SEMI ); } < YYINITIAL >{ NUMBER } { return new Token ( Token . NUMBER , yytext ()); } Cuando tengan listo m\u00e1s de algo, pueden probar lo que hicieron utilizando el siguiente comando: make lexer ./lexer \"2 + 2;\" NUMBER : 2 + NUMBER : 2 ; Aviso: En ocasiones el s\u00edmbolo * puede dar problema al probar esta parte del lab. No se preocupe mucho por esto y siga trabajando las dem\u00e1s partes. 4. Parser \u00b6 Para el segundo ejercicio de este laboratorio ustedes implementar\u00e1n un RDP . Esta gram\u00e1tica es bastante simple y pr\u00e1cticamente se trata solo de expresiones aritm\u00e9ticas. Parsear expresiones de este tipo con recursive descent tiene 2 problemas: Obtener un \u00e1rbol sint\u00e1ctico que siga la precedencia y la asociatividad de los operadores. Hacerlo eficientemente cuando hay muchos niveles de precedencia. En clase ustedes vieron la cl\u00e1sica soluci\u00f3n para el primer problema, que a pesar de que es bastante buena y elegante, no resuelve el segundo problema. En este laboratorio les vamos a ense\u00f1ar una t\u00e9cnica llamada Shunting Yard Algorithm que es m\u00e1s eficiente y resuelve los dos problemas, la base de este algoritmo se encuentra hasta en las calculadoras chicleras . 4.1 Clase Parser \u00b6 En el directorio de trabajo van a encontrar un archivo llamado Parser.java , en este archivo es donde ustedes tienen que implementar el parser. Pr\u00e1cticamente lo que tienen que hacer es crear una plantilla con funciones recursivas de la gramatica que modificamos. Aqu\u00ed hay unas funciones que les pueden ser \u00fatiles como term() . Ejemplo: Si nuestra gram\u00e1tica empieza de esta manera S ::= E; podriamos implementarlo de la siguiente manera. boolean S () { return E () && term ( Token . SEMI ); } boolean E () { ... } 4.2 Shunting Yard Algorithm \u00b6 La idea del algoritmo Shunting Yard es mantener los operadores en un stack hasta que todos los operandos han sido parseados. Los operandos se mantienen en un segundo stack. El algoritmo shunting yard puede utilizarse directamente para evaluar las expresiones mientras son parseadas (como un interprete, que es lo que vamos hacer). La idea central del algoritmo es mantener los operadores en el stack ordenados por precedencia (la precedencia m\u00e1s baja en el fondo del stack y la m\u00e1s alta en el top del stack) , por lo menos en la ausencia de par\u00e9ntesis. Antes de meter un operador en el stack de operadores, todos los operadores que tienen mayor precedencia son sacados del stack. Sacar un operador del stack de operadores consiste en remover el operador y sus operandos del stack de operandos, evaluar, y meter el resultado en el stack de operandos. Al final de una expresi\u00f3n los operadores que quedan son sacados y evaluados con sus respectivos operandos. La siguiente tabla ilustra el proceso para un input : x * y + z. El stack se va llenando a la izquierda. push(a) : hace push de a en el stack de operandos pushOp(op) : hace push de un operador en el stack de operadores pre(op) : devuelve precedencia de un operador 4.3 Precedencia \u00b6 Para nuestra gram\u00e1tica la precedencia es la siguiente de mayor a menor: ( ) - unario ^ * / % + - Dentro del archivo que tienen que modificar, ustedes tienen que llenar con c\u00f3digo donde hay comentarios que dicen /*TODO CODIGO AQUI*/ . Para probar su RDP tienen que hacer lo siguiente: make parser ./parser >>> 2 + 2 ; 4 .0 >>> Entrega \u00b6 Recuerde hacer add + commit + push y subir el link de su repositorio al GES.","title":"3: RDP"},{"location":"labs/lab03/#lab-3-40rdp41","text":"En este laboratorio aprender\u00e1n a implementar un Recursive Descent Parser para una gram\u00e1tica simple.","title":"Lab 3 (RDP)"},{"location":"labs/lab03/#1-introduccion","text":"En las \u00faltimas clases ustedes vieron el tema de Recursive Descent Parsing (RDP para simplificar) , aprendieron que es un tipo de parser predictivo y que entra en la categor\u00eda de top-down parsing. Tambi\u00e9n vieron de forma general un algoritmo para implementarlo y en este laboratorio lo pondremos en pr\u00e1ctica. Como el nombre sugiere, un Recursive Descent Parser usa funciones recursivas para implementar un parser predictivo. La idea central es que cada no terminal en la gram\u00e1tica es representado por una de esas funciones recursivas. Cada funci\u00f3n entonces mira el siguiente token (1 token de lookahead) para poder escoger as\u00ed, una de las producciones de alg\u00fan no-terminal . De esta manera es como vamos analizando la entrada y construyendo nuestro \u00e1rbol (si es que la entrada tiene una sint\u00e1xis correcta, de lo contrario desplegar\u00edamos alg\u00fan error). Recuerden que : Un analizador l\u00e9xico (lexer) convierte texto (raw-text) en un stream de tokens. Un analizador sint\u00e1ctico (parser) convierte el stream de tokens en un AST. De forma gr\u00e1fica esos 2 pasos los podemos ver asi: En este laboratorio realizaremos una calculadora con un par de operaciones e iremos un paso m\u00e1s adelante al implementar un int\u00e9rprete , es decir no crearemos un \u00e1rbol sint\u00e1ctico sino que evaluaremos en el momento las expresiones.","title":"1. Introducci\u00f3n"},{"location":"labs/lab03/#2-gramatica","text":"La gram\u00e1tica con la que trabajaremos es la siguiente: S :: = E ; E :: = E + E | E - E | E * E | E / E | E % E | E ^ E | - E | ( E ) | number # number en nuestro caso significara un double Esta gram\u00e1tica tiene un gran problema para nuestro RDP. Si se recuerdan por lo visto en clase, sufre de un problema llamado left-recursion . Una de las desventajas de este tipo de parsers es que las gram\u00e1ticas con las que puede trabajar son aquellas que no son recursivas hacia la izquierda y claramente esta lo es, E ::= E + E por ejemplo. As\u00ed que lo que necesitamos hacer primero es transformar nuestra gram\u00e1tica para que no tenga este problema, teniendo en cuenta siempre que el lenguaje que describe nuestra nueva gramatica G1 es el mismo que describe nuestra gram\u00e1tica G original, es decir: $$L(G1) = L(G)$$","title":"2. Gram\u00e1tica"},{"location":"labs/lab03/#3-lexer","text":"Para el primer ejercicio de este laboratorio, ustedes van a implementar el lexer para la gram\u00e1tica de nuestra calculadora utilizando JLex . El motivo principal de esto es para que sigan ganando pr\u00e1ctica con esta herramienta, que surgan dudas y que los ayude a empezar/avanzar con el proyecto. Para empezar clonen el siguiente repositorio de Github Classroom: https://classroom.github.com/a/EsfgDA-Z Dentro del repositorio van a encontrar un archivo llamado lexer.lex , en ese archivo ustedes tienen que definir el lexer para la gram\u00e1tica. Dentro de ese archivo hay en forma de comentarios algunas instrucciones para guiarlos.","title":"3. Lexer"},{"location":"labs/lab03/#31-clase-token","text":"En el directorio de trabajo hay una clase llamada Token que nos va a servir para representar los tokens de la gram\u00e1tica y es el tipo de objeto que tenemos que devolver dentro de las acciones del lexer. Esta clase tiene 2 constructores: Token(int id, String val) Token(int id) Dentro de esta clase tambi\u00e9n est\u00e1n definidos los IDs que representan cada token y tienen que hacer uso de ellos cuando encuentren un token. En ese archivo tambi\u00e9n est\u00e1n definidos otros m\u00e9todos que pueden ser \u00fatiles para la siguiente parte del laboratorio. Ejemplo: // Asi se veria en la parte de acciones del archivo .lex < YYINITIAL >{ SEMI } { return new Token ( Token . SEMI ); } < YYINITIAL >{ NUMBER } { return new Token ( Token . NUMBER , yytext ()); } Cuando tengan listo m\u00e1s de algo, pueden probar lo que hicieron utilizando el siguiente comando: make lexer ./lexer \"2 + 2;\" NUMBER : 2 + NUMBER : 2 ; Aviso: En ocasiones el s\u00edmbolo * puede dar problema al probar esta parte del lab. No se preocupe mucho por esto y siga trabajando las dem\u00e1s partes.","title":"3.1 Clase Token"},{"location":"labs/lab03/#4-parser","text":"Para el segundo ejercicio de este laboratorio ustedes implementar\u00e1n un RDP . Esta gram\u00e1tica es bastante simple y pr\u00e1cticamente se trata solo de expresiones aritm\u00e9ticas. Parsear expresiones de este tipo con recursive descent tiene 2 problemas: Obtener un \u00e1rbol sint\u00e1ctico que siga la precedencia y la asociatividad de los operadores. Hacerlo eficientemente cuando hay muchos niveles de precedencia. En clase ustedes vieron la cl\u00e1sica soluci\u00f3n para el primer problema, que a pesar de que es bastante buena y elegante, no resuelve el segundo problema. En este laboratorio les vamos a ense\u00f1ar una t\u00e9cnica llamada Shunting Yard Algorithm que es m\u00e1s eficiente y resuelve los dos problemas, la base de este algoritmo se encuentra hasta en las calculadoras chicleras .","title":"4. Parser"},{"location":"labs/lab03/#41-clase-parser","text":"En el directorio de trabajo van a encontrar un archivo llamado Parser.java , en este archivo es donde ustedes tienen que implementar el parser. Pr\u00e1cticamente lo que tienen que hacer es crear una plantilla con funciones recursivas de la gramatica que modificamos. Aqu\u00ed hay unas funciones que les pueden ser \u00fatiles como term() . Ejemplo: Si nuestra gram\u00e1tica empieza de esta manera S ::= E; podriamos implementarlo de la siguiente manera. boolean S () { return E () && term ( Token . SEMI ); } boolean E () { ... }","title":"4.1 Clase Parser"},{"location":"labs/lab03/#42-shunting-yard-algorithm","text":"La idea del algoritmo Shunting Yard es mantener los operadores en un stack hasta que todos los operandos han sido parseados. Los operandos se mantienen en un segundo stack. El algoritmo shunting yard puede utilizarse directamente para evaluar las expresiones mientras son parseadas (como un interprete, que es lo que vamos hacer). La idea central del algoritmo es mantener los operadores en el stack ordenados por precedencia (la precedencia m\u00e1s baja en el fondo del stack y la m\u00e1s alta en el top del stack) , por lo menos en la ausencia de par\u00e9ntesis. Antes de meter un operador en el stack de operadores, todos los operadores que tienen mayor precedencia son sacados del stack. Sacar un operador del stack de operadores consiste en remover el operador y sus operandos del stack de operandos, evaluar, y meter el resultado en el stack de operandos. Al final de una expresi\u00f3n los operadores que quedan son sacados y evaluados con sus respectivos operandos. La siguiente tabla ilustra el proceso para un input : x * y + z. El stack se va llenando a la izquierda. push(a) : hace push de a en el stack de operandos pushOp(op) : hace push de un operador en el stack de operadores pre(op) : devuelve precedencia de un operador","title":"4.2 Shunting Yard Algorithm"},{"location":"labs/lab03/#43-precedencia","text":"Para nuestra gram\u00e1tica la precedencia es la siguiente de mayor a menor: ( ) - unario ^ * / % + - Dentro del archivo que tienen que modificar, ustedes tienen que llenar con c\u00f3digo donde hay comentarios que dicen /*TODO CODIGO AQUI*/ . Para probar su RDP tienen que hacer lo siguiente: make parser ./parser >>> 2 + 2 ; 4 .0 >>>","title":"4.3 Precedencia"},{"location":"labs/lab03/#entrega","text":"Recuerde hacer add + commit + push y subir el link de su repositorio al GES.","title":"Entrega"},{"location":"labs/lab04/","text":"Lab 4 (JCUP) \u00b6 En este laboratorio aprender\u00e1n a utilizar cup , el analizador sint\u00e1ctico para la fase 2 del proyecto. 1. Introducci\u00f3n \u00b6 Descarguen todos los archivos del siguiente repositorio: https://classroom.github.com/a/eV_cMHnC Ahora que han terminado la fase 1 de su proyecto, saben utilizar JLex para el an\u00e1lisis l\u00e9xico de una cadena de caracteres. Como han visto en clase, el an\u00e1lisis sint\u00e1ctico se basa en gram\u00e1ticas, y tiene algoritmos muy bien definidos para poder ser implementado. Para prepararlos para la fase 2, utilizaremos una herramienta llamada cup que funciona para analizar la sint\u00e1xis de un texto dado. Al igual que JLex, cup cuenta con una secci\u00f3n en donde se colocan las funciones que posteriormente se copiar\u00e1n en la clase generada. En este laboratorio no utilizaremos esta funcionalidad, pero les ser\u00e1 \u00fatil para su proyecto. Luego existe una lista de s\u00edmbolos terminales, como los par\u00e9ntesis, los d\u00edgitos, etc., seguido de una lista de s\u00edmbolos no terminales. Tanto los s\u00edmbolos terminales como los no terminales pueden tener un tipo definido: terminal PLUS , MINUS , MULT ; terminal Integer INTEGER ; terminal Float FLOAT ; Luego pueden especificar una precedencia. Por ejemplo, una multiplicaci\u00f3n se debe hacer antes que una suma. A continuaci\u00f3n un ejemplo: precedence left PLUS , MINUS ; precedence left TIMES ; Es importante recordar que a cup no le importa la aritm\u00e9tica, le importan los \u00e1rboles. Esto quiere decir que un operador con una mayor precedencia quedar\u00e1 m\u00e1s cerca de la ra\u00edz de su \u00e1rbol. Seguido de eso, van todas las reglas de producci\u00f3n. Usamos la siguiente sint\u00e1xis, en donde RESULT es un dato que estaremos haciendo disponible para que nuestro nodo padre pueda utilizar. parent_expr ::= LPAREN expr : e RPAREN {: RESULT = e ; :}; 2. Lexer \u00b6 La gram\u00e1tica con la que trabajaremos es la siguiente: S :: = S expr_part | expr_part expr_part :: = expr ; expr :: = exprI | exprF exprI :: = exprI + exprI | exprI - exprI | exprI * exprI | exprI / exprI | exprI % exprI | ( exprI ) | I exprF :: = exprI + exprF | exprF + exprI | exprF + exprF | exprI - exprF | exprF - exprI | exprF - exprF | exprI * exprF | exprF * exprI | exprF * exprF | exprI / exprF | exprF / exprI | exprF / exprF | exprI ^ exprF | exprF ^ exprI | exprF ^ exprF | sin ( exprI ) | sin ( exprF ) | cos ( exprI ) | cos ( exprF ) | tan ( exprI ) | tan ( exprF ) | ( exprF ) | F # donde I es un token entero y F es un token float # noten que # expr_part ::= expr ; # nos indica que debemos colocar un punto y coma Para la primer parte deben completar el archivo calculator.lex generando los tokens necesarios para una calculadora con operaciones b\u00e1sicas y que maneje tanto floats como enteros. Esta es la lista de tokens que debe tener: SEMI PLUS MINUS TIMES DIVI LPAREN RPAREN POW REM SIN COS TAN INTEGER FLOAT 3. Parser \u00b6 Para la segunda parte, ustedes deben completar el archivo calculator.cup , agregando las reglas de derivaci\u00f3n. Pueden agregar tantos s\u00edmbolos no terminales como quieran, pero no pueden modificar ninguno de los s\u00edmbolos terminales. Una vez agregadas todas las reglas de derivaci\u00f3n, pueden compilar su archivo de la siguiente manera: sh make.sh y para correrlo: sh calculator.sh As\u00ed se deber\u00e1 de ver al probarlo: 2 + 2 ; = 4 ; 10 * sin ( 90 ) - 1 ; = 9 ; Puede trabajar las trigonom\u00e9tricas en grados o radianes, solo deje indicado en un comentario cu\u00e1l utiliz\u00f3. Una vez terminado, tienen que realizar un commit de los archivos .cup y .lex y subir al GES el link de su repositorio. Referencias \u00b6 cup Manual - Manual de JCup. cup Javadoc - Javadoc de JCup.","title":"4: cup"},{"location":"labs/lab04/#lab-4-40jcup41","text":"En este laboratorio aprender\u00e1n a utilizar cup , el analizador sint\u00e1ctico para la fase 2 del proyecto.","title":"Lab 4 (JCUP)"},{"location":"labs/lab04/#1-introduccion","text":"Descarguen todos los archivos del siguiente repositorio: https://classroom.github.com/a/eV_cMHnC Ahora que han terminado la fase 1 de su proyecto, saben utilizar JLex para el an\u00e1lisis l\u00e9xico de una cadena de caracteres. Como han visto en clase, el an\u00e1lisis sint\u00e1ctico se basa en gram\u00e1ticas, y tiene algoritmos muy bien definidos para poder ser implementado. Para prepararlos para la fase 2, utilizaremos una herramienta llamada cup que funciona para analizar la sint\u00e1xis de un texto dado. Al igual que JLex, cup cuenta con una secci\u00f3n en donde se colocan las funciones que posteriormente se copiar\u00e1n en la clase generada. En este laboratorio no utilizaremos esta funcionalidad, pero les ser\u00e1 \u00fatil para su proyecto. Luego existe una lista de s\u00edmbolos terminales, como los par\u00e9ntesis, los d\u00edgitos, etc., seguido de una lista de s\u00edmbolos no terminales. Tanto los s\u00edmbolos terminales como los no terminales pueden tener un tipo definido: terminal PLUS , MINUS , MULT ; terminal Integer INTEGER ; terminal Float FLOAT ; Luego pueden especificar una precedencia. Por ejemplo, una multiplicaci\u00f3n se debe hacer antes que una suma. A continuaci\u00f3n un ejemplo: precedence left PLUS , MINUS ; precedence left TIMES ; Es importante recordar que a cup no le importa la aritm\u00e9tica, le importan los \u00e1rboles. Esto quiere decir que un operador con una mayor precedencia quedar\u00e1 m\u00e1s cerca de la ra\u00edz de su \u00e1rbol. Seguido de eso, van todas las reglas de producci\u00f3n. Usamos la siguiente sint\u00e1xis, en donde RESULT es un dato que estaremos haciendo disponible para que nuestro nodo padre pueda utilizar. parent_expr ::= LPAREN expr : e RPAREN {: RESULT = e ; :};","title":"1. Introducci\u00f3n"},{"location":"labs/lab04/#2-lexer","text":"La gram\u00e1tica con la que trabajaremos es la siguiente: S :: = S expr_part | expr_part expr_part :: = expr ; expr :: = exprI | exprF exprI :: = exprI + exprI | exprI - exprI | exprI * exprI | exprI / exprI | exprI % exprI | ( exprI ) | I exprF :: = exprI + exprF | exprF + exprI | exprF + exprF | exprI - exprF | exprF - exprI | exprF - exprF | exprI * exprF | exprF * exprI | exprF * exprF | exprI / exprF | exprF / exprI | exprF / exprF | exprI ^ exprF | exprF ^ exprI | exprF ^ exprF | sin ( exprI ) | sin ( exprF ) | cos ( exprI ) | cos ( exprF ) | tan ( exprI ) | tan ( exprF ) | ( exprF ) | F # donde I es un token entero y F es un token float # noten que # expr_part ::= expr ; # nos indica que debemos colocar un punto y coma Para la primer parte deben completar el archivo calculator.lex generando los tokens necesarios para una calculadora con operaciones b\u00e1sicas y que maneje tanto floats como enteros. Esta es la lista de tokens que debe tener: SEMI PLUS MINUS TIMES DIVI LPAREN RPAREN POW REM SIN COS TAN INTEGER FLOAT","title":"2. Lexer"},{"location":"labs/lab04/#3-parser","text":"Para la segunda parte, ustedes deben completar el archivo calculator.cup , agregando las reglas de derivaci\u00f3n. Pueden agregar tantos s\u00edmbolos no terminales como quieran, pero no pueden modificar ninguno de los s\u00edmbolos terminales. Una vez agregadas todas las reglas de derivaci\u00f3n, pueden compilar su archivo de la siguiente manera: sh make.sh y para correrlo: sh calculator.sh As\u00ed se deber\u00e1 de ver al probarlo: 2 + 2 ; = 4 ; 10 * sin ( 90 ) - 1 ; = 9 ; Puede trabajar las trigonom\u00e9tricas en grados o radianes, solo deje indicado en un comentario cu\u00e1l utiliz\u00f3. Una vez terminado, tienen que realizar un commit de los archivos .cup y .lex y subir al GES el link de su repositorio.","title":"3. Parser"},{"location":"labs/lab04/#referencias","text":"cup Manual - Manual de JCup. cup Javadoc - Javadoc de JCup.","title":"Referencias"},{"location":"labs/lab05/","text":"Lab 5 (Symbol Table) \u00b6 En este laboratorio aprender\u00e1n a implementar una tabla de s\u00edmbolos como la que usar\u00e1n en la fase 3 del proyecto. 1. Introducci\u00f3n \u00b6 Han terminado las primeras 2 fases de su proyecto y ahora es donde empieza la verdadera batalla contra el drag\u00f3n. En la fase 3 se encargar\u00e1n de hacer el an\u00e1lisis sem\u00e1ntico del compilador, es decir, deber\u00e1n asignar un tipo a cada nodo del \u00e1rbol generado en la fase 2 y as\u00ed terminar de capturar cualquier error o inconsistencia en el c\u00f3digo o programa a compilar. Para realizar esta fase, ustedes deben implementar una tabla de s\u00edmbolos en donde guardar\u00e1n todas las variables declaradas para validar su existencia en base a su scope, y poder asignar un tipo a cada una. Para iniciar, ejecuten el comando para generar los archivos necesarios: make -f /usr/class/cc4/assignments/PA3/Makefile 2. Tabla de S\u00edmbolos \u00b6 Estos son los archivos necesarios para implementar la fase 3 del proyecto, pero por ahora nos enfocaremos \u00fanicamente en SymtabExample.java . Noten que este archivo contiene un ejemplo de como funciona la tabla de s\u00edmbolos: // se crea la tabla de sibolos. SymbolTable map = new SymbolTable (); // se crea un nuevo AbstractSymbol AbstractSymbol fred = AbstractTable . stringtable . addString ( \"Fred\" ); // se agrega un nuevo scope a la tabla. Notese que al crear la tabla, esta no contiene ningun scope map . enterScope (); // se agrega el simbolo a la tabla junto con un valor map . addId ( fred , new Integer ( 22 )); // busca y devuelve el valor asociado al simbolo en el scope actual, si no lo encuentra, devuelve null map . probe ( fred ) // busca y devuelve el valor asociado al simbolo en todos los scopes, si no lo encuentra, devuelve null map . lookup ( fred ) // elimina el ultimo scope creado. map . exitScope (); La tabla de s\u00edmbolos ( SymbolTable.java ), en su implementaci\u00f3n utiliza un stack para los scopes, y adicional al ejemplo que tienen en el archivo, estos son los m\u00e9todos que contiene la clase: // un constructor sin parametros que inicializa la tabla public SymbolTable () // agrega un nuevo scope a la tabla, en forma de una HashTable public void enterScope () // elimina el ultimo scope agregado public void exitScope () // agrega una entrada a la tabla en el scope mas reciente public void addId ( AbstractSymbol id , Object info ) // busca y devuelve el valor del simbolo. Busca unicamente en el scope mas reciente public Object probe ( AbstractSymbol sym ) // busca en todos los scopes de la tabla. Devuelve el valor del simbolo mas reciente que encontro public Object lookup ( AbstractSymbol sym ) // devuelve un String que representa la tabla public String toString () Vean que las entradas de la tabla de s\u00edmbolos son pares (Key,Value), donde la llave es de tipo AbstractSymbol y el valor es de tipo Object . En este laboratorio, para simplificar la calificaci\u00f3n, ingresaremos \u00fanicamente valores de tipo String . Ahora que se han familiarizado un poco con la tabla de s\u00edmbolos, es hora de modificar el archivo SymtabExample.java . Agreguen a este un men\u00fa en el que se puedan realizar las siguientes operaciones: Agregar S\u00edmbolo Agregar Scope Borrar Scope Buscar en el scope actual (devolver el valor almacenado con el s\u00edmbolo) Buscar en cualquier scope (devolver el valor almacenado con el s\u00edmbolo) Comparar el valor de 2 simbolos diferentes Imprimir tabla de s\u00edmbolos Salir Para compilar su programa deben de hacer lo siguiente: make symtab-example Para ejecutarlo: ./symtab-example Una vez terminado todo, env\u00eden al GES un archivo .zip conteniendo \u00fanicamente el archivo SymtabExample.java","title":"5: SymbolTable"},{"location":"labs/lab05/#lab-5-40symbol-table41","text":"En este laboratorio aprender\u00e1n a implementar una tabla de s\u00edmbolos como la que usar\u00e1n en la fase 3 del proyecto.","title":"Lab 5 (Symbol Table)"},{"location":"labs/lab05/#1-introduccion","text":"Han terminado las primeras 2 fases de su proyecto y ahora es donde empieza la verdadera batalla contra el drag\u00f3n. En la fase 3 se encargar\u00e1n de hacer el an\u00e1lisis sem\u00e1ntico del compilador, es decir, deber\u00e1n asignar un tipo a cada nodo del \u00e1rbol generado en la fase 2 y as\u00ed terminar de capturar cualquier error o inconsistencia en el c\u00f3digo o programa a compilar. Para realizar esta fase, ustedes deben implementar una tabla de s\u00edmbolos en donde guardar\u00e1n todas las variables declaradas para validar su existencia en base a su scope, y poder asignar un tipo a cada una. Para iniciar, ejecuten el comando para generar los archivos necesarios: make -f /usr/class/cc4/assignments/PA3/Makefile","title":"1. Introducci\u00f3n"},{"location":"labs/lab05/#2-tabla-de-simbolos","text":"Estos son los archivos necesarios para implementar la fase 3 del proyecto, pero por ahora nos enfocaremos \u00fanicamente en SymtabExample.java . Noten que este archivo contiene un ejemplo de como funciona la tabla de s\u00edmbolos: // se crea la tabla de sibolos. SymbolTable map = new SymbolTable (); // se crea un nuevo AbstractSymbol AbstractSymbol fred = AbstractTable . stringtable . addString ( \"Fred\" ); // se agrega un nuevo scope a la tabla. Notese que al crear la tabla, esta no contiene ningun scope map . enterScope (); // se agrega el simbolo a la tabla junto con un valor map . addId ( fred , new Integer ( 22 )); // busca y devuelve el valor asociado al simbolo en el scope actual, si no lo encuentra, devuelve null map . probe ( fred ) // busca y devuelve el valor asociado al simbolo en todos los scopes, si no lo encuentra, devuelve null map . lookup ( fred ) // elimina el ultimo scope creado. map . exitScope (); La tabla de s\u00edmbolos ( SymbolTable.java ), en su implementaci\u00f3n utiliza un stack para los scopes, y adicional al ejemplo que tienen en el archivo, estos son los m\u00e9todos que contiene la clase: // un constructor sin parametros que inicializa la tabla public SymbolTable () // agrega un nuevo scope a la tabla, en forma de una HashTable public void enterScope () // elimina el ultimo scope agregado public void exitScope () // agrega una entrada a la tabla en el scope mas reciente public void addId ( AbstractSymbol id , Object info ) // busca y devuelve el valor del simbolo. Busca unicamente en el scope mas reciente public Object probe ( AbstractSymbol sym ) // busca en todos los scopes de la tabla. Devuelve el valor del simbolo mas reciente que encontro public Object lookup ( AbstractSymbol sym ) // devuelve un String que representa la tabla public String toString () Vean que las entradas de la tabla de s\u00edmbolos son pares (Key,Value), donde la llave es de tipo AbstractSymbol y el valor es de tipo Object . En este laboratorio, para simplificar la calificaci\u00f3n, ingresaremos \u00fanicamente valores de tipo String . Ahora que se han familiarizado un poco con la tabla de s\u00edmbolos, es hora de modificar el archivo SymtabExample.java . Agreguen a este un men\u00fa en el que se puedan realizar las siguientes operaciones: Agregar S\u00edmbolo Agregar Scope Borrar Scope Buscar en el scope actual (devolver el valor almacenado con el s\u00edmbolo) Buscar en cualquier scope (devolver el valor almacenado con el s\u00edmbolo) Comparar el valor de 2 simbolos diferentes Imprimir tabla de s\u00edmbolos Salir Para compilar su programa deben de hacer lo siguiente: make symtab-example Para ejecutarlo: ./symtab-example Una vez terminado todo, env\u00eden al GES un archivo .zip conteniendo \u00fanicamente el archivo SymtabExample.java","title":"2. Tabla de S\u00edmbolos"},{"location":"labs/lab06/","text":"Lab 6 (An\u00e1lisis Sem\u00e1ntico I) \u00b6 Es hora de empezar a poner en pr\u00e1ctica el an\u00e1lisis sem\u00e1ntico. El motivo de este laboratorio es que puedan ganar experiencia en como se hace el an\u00e1lisis sem\u00e1ntico de un lenguaje simple y que posteriormente en su proyecto plasmen estas ideas. En el laboratorio anterior se enteraron de como funcionaba la tabla de s\u00edmbolos, en este la vamos a utilizar juntamente con otras herramientas para anotar el \u00e1rbol ( AST ) de un lenguaje llamado Viper con los tipos correspondientes. Antes de empezar, vamos a obtener los archivos necesarios desde Github Classroom: https://classroom.github.com/a/EmL-zwJ1 Lean bien Este lab es m\u00e1s complejo que los anteriores, por favor lean todas las instrucciones del lab, antes de empezar. An\u00e1lisis Sem\u00e1ntico del lenguaje Viper \u00b6 En este laboratorio haremos el an\u00e1lisis sem\u00e1ntico de algunos nodos del lenguaje Viper, as\u00ed que los introduciremos a el un poco. Lenguaje Viper \u00b6 Viper es un lenguaje bastante b\u00e1sico, es una mezcla de Python y C, y nos ayudar\u00e1 a entender mejor algunos conceptos de Semantic y Codegen por lo que deber\u00e1n acostumbrarse un poco al lenguaje. Gram\u00e1tica de Viper La mejor forma de entender este lenguaje es revisando la gram\u00e1tica. Una vez hayan visto/entendido la gram\u00e1tica, esto les parecera conocido: def factorial ( n : int ): int { int result = 0 ; if ( n < 2 ) { result = 1 ; } else { result = n * factorial ( n - 1 ); } return result ; } Reglas de inferencia del lenguaje Viper \u00b6 Viper tiene pocas reglas de inferencia a comparaci\u00f3n de COOL y son menos complejas, sin embargo ayudan a entender bastante la din\u00e1mica de lo que tendr\u00edan que hacer en el proyecto, solo que sin objetos. Para ver estas reglas, pueden descargar el siguiente archivo: Reglas de inferencia de Viper En ese documento est\u00e1n las reglas en el mismo formato que el manual de COOL , solo que en espa\u00f1ol y que son para el lenguaje Viper obviamente. \u00bfQu\u00e9 tienen que hacer? \u00b6 En los archivos de lab dentro de src/viper/tree est\u00e1n los nodos que representan el AST de un programa de Viper. En algunos de estos nodos ustedes tendr\u00e1n que realizar el an\u00e1lisis sem\u00e1ntico para completar el laboratorio. Los nodos que tienen que analizar esta semana son los siguientes: Function BoolConst IntConst StrConst Add Sub Mul Div Mod Return En el lenguaje Viper existen statements y expressions . Las expresiones son las que siempre devuelven un valor y se les asigna un tipo, los statements no. Para asignar un tipo a una expresi\u00f3n vean la funci\u00f3n semant() del nodo NoReturn para ver como es que se le asigna un tipo a una expresi\u00f3n utilizando la clase Type , adem\u00e1s vean la clase Type para ver los m\u00e9todos que tiene, porque les va a servir tenerlos en mente. Tambi\u00e9n van a notar como est\u00e1 declarada la funci\u00f3n semant() en los nodos del AST: public void semant ( SymbolTable O , HashMap < String , Function > M ) { // WRITE YOUR CODE HERE } O es la tabla de s\u00edmbolos que utilizaron en el laboratorio anterior, M es el entorno de funciones que hace un mapping de nombre de funci\u00f3n a Function (esto es \u00fatil porque as\u00ed se puede extraer f\u00e1cilmente los formals y el tipo de retorno). Algo as\u00ed tendr\u00eda que verse su m\u00e9todo semant*() en su proyecto, solo que con las cosas de COOL y tomando en cuenta los nombres de clases y que son AbstractSymbol . En este laboratorio no vamos a utilizar a M . Para que tengan una referencia, de que tanto tendr\u00edan que agregar a los diferentes archivos, aqu\u00ed est\u00e1n las estad\u00edsticas de nuestra implementaci\u00f3n: src/viper/tree/Add.java | 7 ++++++- src/viper/tree/BoolConst.java | 2 +- src/viper/tree/Div.java | 7 ++++++- src/viper/tree/Function.java | 30 +++++++++++++++++++++++++++++- src/viper/tree/IntConst.java | 4 ++-- src/viper/tree/Mod.java | 7 ++++++- src/viper/tree/Mul.java | 7 ++++++- src/viper/tree/Return.java | 3 ++- src/viper/tree/StrConst.java | 4 ++-- src/viper/tree/Sub.java | 7 ++++++- 10 files changed, 66 insertions ( + ) , 12 deletions ( - ) Implementaci\u00f3n \u00b6 Para cada nodo del AST hay una serie de pasos que se tienen que realizar para garantizar que el an\u00e1lisis sem\u00e1ntico capture todos los errores posibles, recuerden que esta es nuestra \u00faltima barrera antes de codegen para atrapar errores. An\u00e1lisis de Function \u00b6 El an\u00e1lisis de las funciones es lo m\u00e1s complejo que realizar\u00e1n de este laboratorio. Recuerden que como se pueden declarar par\u00e1metros formales y variables dentro de una funci\u00f3n, esta crea un scope nuevo, utilicen lo siguiente para crear un nuevo scope: O . enterScope () Scopes Por lo general podemos decir que en Viper cada par de llaves {} crean un nuevo scope Si la funci\u00f3n se llama main hay un par de cosas que se tienen que considerar, una de ellas es que la funci\u00f3n main no puede tener par\u00e1metros definidos y la otra es que siempre tiene que tener un tipo de retorno int . Cuando sea el caso que tenga par\u00e1metros definidos tienen que utilizar lo siguiente para imprimir un error: SemantErrors . mainFunctionShouldHaveNoArgs ( line , col ) Cantidad de formals de main Utilicen formals.size() para verificar esto. line y col Noten que todos los nodos en Viper tienen definido un line y un col ya que heredan de la clase Node . Y cuando tenga un tipo de retorno diferente de int , tienen que utilizar lo siguiente: SemantErrors . mainFunctionShouldHaveAnIntRetType ( line , col ) Ustedes tienen que agregar los formals al scope que acaban de crear, pero ustedes tienen que verificar que los nombres de los par\u00e1metros no se repitan, por ejemplo esto estar\u00eda incorrecto: def foo ( x : int , x : int ) Cuando suceda lo anterior tienen que utilizar lo siguiente: SemantErrors . formalIsAlreadyDefined ( formal . line , formal . col , formal . name ) Agregar formal Utilicen lo siguiente para agregar el formal al scope actual: O . add ( formal . name , formal . type ) Noten que como valor mandamos el tipo del formal \u00bfPor qu\u00e9? Tipo formal tiene que ser una instancia de la clase Formal Despu\u00e9s deber\u00edan de mandar a llamar recursivamente a semant para los statements y la expresi\u00f3n de retorno ret . Cuando estas dos llamadas regresen si ret no tiene tipo void y la funci\u00f3n si, tienen utilizar lo siguiente para reportar el error: SemantErrors . unexpectedReturnValue ( ret . line , ret . col ) Si ret es void y la funci\u00f3n tiene un tipo de retorno diferente de void utilizar lo siguiente: SemantErrors . missingReturnStatement ( line , col ) Y en general si ret no es igual al tipo de retorno de la funci\u00f3n entonces: SemantErrors . incompatibleTypes ( ret . line , ret . col , ret . getType (), type ) Al finalizar el an\u00e1lisis deber\u00edan de cerrar el scope, para evitar otros errores: O . exitScope () Constantes \u00b6 Esto es bastante sencillo, si es una constante entera, el tipo de la expresi\u00f3n es int . Lo mismo pasa con las dem\u00e1s constantes, strings str y booleans bool . Operaciones Aritm\u00e9ticas \u00b6 Primero tienen que mandar a llamar recursivamente a semant de las expresiones que conforman el nodo. Las operaciones aritm\u00e9ticas siempre tienen que tener operandos de tipo int y siempre devuelven como resultado un int . Cuando alg\u00fan operando no sea de tipo int tienen que utilizar el siguiente errror: SemantErrors . badOperandTypesForBinaryOp ( line , col , operator ) Operadores operator tiene que ser un String que represente la operaci\u00f3n binaria, por ejemplo \"+\" Siempre tienen que asumir que el tipo de una expresi\u00f3n aritm\u00e9tica es un int , de lo contrario nos encontrariamos con errores en cascada poco informativos, consideren lo siguiente: true + 2 + 2 + 2 Si no asumieramos lo de arriba pasar\u00eda lo siguiente: bad operand types for binary operator '+' bad operand types for binary operator '+' bad operand types for binary operator '+' A pesar que solo el primer operando de esa serie de sumas es el incorrecto. Lo correcto ser\u00eda desplegar lo siguiente: bad operand types for binary operator '+' Esto es una forma de recuperaci\u00f3n de errores que tambi\u00e9n van a tener que realizar en su proyecto. Vamos a mentir En otras palabras, implementaremos lo visto en clase. Aunque suceda un error, mentiremos y reportaremos que nuestra operaci\u00f3n aritm\u00e9tica tiene tipo Int , esto nos ayuda a que el error no se propague sino que se reporte una sola vez. Return \u00b6 Cuando hagan el an\u00e1lisis sem\u00e1ntico de Return recuerden que el tipo del return es el mismo que el de la expresi\u00f3n e del return. Autograder \u00b6 Para compilar un programa usando el semantic que acaba de implementar, use el comando: sudo ./gradlew build ./run -viper examples/viper/nombreDelArchivo.vp Para correr todas las pruebas, use el comando: sudo ./gradlew build ./check viper Si todo lo tienen bien, les deber\u00eda de salir lo siguiente: Autograder +1 ( unexpectedreturn ) +1 ( diffrettype ) +1 ( arith ) +1 ( mainwithargs ) +1 ( basic ) +1 ( badarith ) +1 ( mainnoint ) +1 ( good ) +1 ( badformals ) +1 ( string ) +1 ( bool ) +1 ( missingret ) = > You got a score of 12 out of 12 . Si necesitara compilar alg\u00fan archivo con nuestro compilador de pruebas puede usar el siguiente comando. Esto le servir\u00e1 principalmente cuando lleguemos a codegen. ./vipercl examples/viper/nombreDelArchivo.vp Luego de haber compilado, use el siguiente comando para ejecutar. ./jupiter runtime/runtime.s examples/viper/nombreDelArchivo.s","title":"6: Semantic 1"},{"location":"labs/lab06/#lab-6-40analisis-semantico-i41","text":"Es hora de empezar a poner en pr\u00e1ctica el an\u00e1lisis sem\u00e1ntico. El motivo de este laboratorio es que puedan ganar experiencia en como se hace el an\u00e1lisis sem\u00e1ntico de un lenguaje simple y que posteriormente en su proyecto plasmen estas ideas. En el laboratorio anterior se enteraron de como funcionaba la tabla de s\u00edmbolos, en este la vamos a utilizar juntamente con otras herramientas para anotar el \u00e1rbol ( AST ) de un lenguaje llamado Viper con los tipos correspondientes. Antes de empezar, vamos a obtener los archivos necesarios desde Github Classroom: https://classroom.github.com/a/EmL-zwJ1 Lean bien Este lab es m\u00e1s complejo que los anteriores, por favor lean todas las instrucciones del lab, antes de empezar.","title":"Lab 6 (An\u00e1lisis Sem\u00e1ntico I)"},{"location":"labs/lab06/#analisis-semantico-del-lenguaje-viper","text":"En este laboratorio haremos el an\u00e1lisis sem\u00e1ntico de algunos nodos del lenguaje Viper, as\u00ed que los introduciremos a el un poco.","title":"An\u00e1lisis Sem\u00e1ntico del lenguaje Viper"},{"location":"labs/lab06/#lenguaje-viper","text":"Viper es un lenguaje bastante b\u00e1sico, es una mezcla de Python y C, y nos ayudar\u00e1 a entender mejor algunos conceptos de Semantic y Codegen por lo que deber\u00e1n acostumbrarse un poco al lenguaje. Gram\u00e1tica de Viper La mejor forma de entender este lenguaje es revisando la gram\u00e1tica. Una vez hayan visto/entendido la gram\u00e1tica, esto les parecera conocido: def factorial ( n : int ): int { int result = 0 ; if ( n < 2 ) { result = 1 ; } else { result = n * factorial ( n - 1 ); } return result ; }","title":"Lenguaje Viper"},{"location":"labs/lab06/#reglas-de-inferencia-del-lenguaje-viper","text":"Viper tiene pocas reglas de inferencia a comparaci\u00f3n de COOL y son menos complejas, sin embargo ayudan a entender bastante la din\u00e1mica de lo que tendr\u00edan que hacer en el proyecto, solo que sin objetos. Para ver estas reglas, pueden descargar el siguiente archivo: Reglas de inferencia de Viper En ese documento est\u00e1n las reglas en el mismo formato que el manual de COOL , solo que en espa\u00f1ol y que son para el lenguaje Viper obviamente.","title":"Reglas de inferencia del lenguaje Viper"},{"location":"labs/lab06/#que-tienen-que-hacer","text":"En los archivos de lab dentro de src/viper/tree est\u00e1n los nodos que representan el AST de un programa de Viper. En algunos de estos nodos ustedes tendr\u00e1n que realizar el an\u00e1lisis sem\u00e1ntico para completar el laboratorio. Los nodos que tienen que analizar esta semana son los siguientes: Function BoolConst IntConst StrConst Add Sub Mul Div Mod Return En el lenguaje Viper existen statements y expressions . Las expresiones son las que siempre devuelven un valor y se les asigna un tipo, los statements no. Para asignar un tipo a una expresi\u00f3n vean la funci\u00f3n semant() del nodo NoReturn para ver como es que se le asigna un tipo a una expresi\u00f3n utilizando la clase Type , adem\u00e1s vean la clase Type para ver los m\u00e9todos que tiene, porque les va a servir tenerlos en mente. Tambi\u00e9n van a notar como est\u00e1 declarada la funci\u00f3n semant() en los nodos del AST: public void semant ( SymbolTable O , HashMap < String , Function > M ) { // WRITE YOUR CODE HERE } O es la tabla de s\u00edmbolos que utilizaron en el laboratorio anterior, M es el entorno de funciones que hace un mapping de nombre de funci\u00f3n a Function (esto es \u00fatil porque as\u00ed se puede extraer f\u00e1cilmente los formals y el tipo de retorno). Algo as\u00ed tendr\u00eda que verse su m\u00e9todo semant*() en su proyecto, solo que con las cosas de COOL y tomando en cuenta los nombres de clases y que son AbstractSymbol . En este laboratorio no vamos a utilizar a M . Para que tengan una referencia, de que tanto tendr\u00edan que agregar a los diferentes archivos, aqu\u00ed est\u00e1n las estad\u00edsticas de nuestra implementaci\u00f3n: src/viper/tree/Add.java | 7 ++++++- src/viper/tree/BoolConst.java | 2 +- src/viper/tree/Div.java | 7 ++++++- src/viper/tree/Function.java | 30 +++++++++++++++++++++++++++++- src/viper/tree/IntConst.java | 4 ++-- src/viper/tree/Mod.java | 7 ++++++- src/viper/tree/Mul.java | 7 ++++++- src/viper/tree/Return.java | 3 ++- src/viper/tree/StrConst.java | 4 ++-- src/viper/tree/Sub.java | 7 ++++++- 10 files changed, 66 insertions ( + ) , 12 deletions ( - )","title":"\u00bfQu\u00e9 tienen que hacer?"},{"location":"labs/lab06/#implementacion","text":"Para cada nodo del AST hay una serie de pasos que se tienen que realizar para garantizar que el an\u00e1lisis sem\u00e1ntico capture todos los errores posibles, recuerden que esta es nuestra \u00faltima barrera antes de codegen para atrapar errores.","title":"Implementaci\u00f3n"},{"location":"labs/lab06/#analisis-de-function","text":"El an\u00e1lisis de las funciones es lo m\u00e1s complejo que realizar\u00e1n de este laboratorio. Recuerden que como se pueden declarar par\u00e1metros formales y variables dentro de una funci\u00f3n, esta crea un scope nuevo, utilicen lo siguiente para crear un nuevo scope: O . enterScope () Scopes Por lo general podemos decir que en Viper cada par de llaves {} crean un nuevo scope Si la funci\u00f3n se llama main hay un par de cosas que se tienen que considerar, una de ellas es que la funci\u00f3n main no puede tener par\u00e1metros definidos y la otra es que siempre tiene que tener un tipo de retorno int . Cuando sea el caso que tenga par\u00e1metros definidos tienen que utilizar lo siguiente para imprimir un error: SemantErrors . mainFunctionShouldHaveNoArgs ( line , col ) Cantidad de formals de main Utilicen formals.size() para verificar esto. line y col Noten que todos los nodos en Viper tienen definido un line y un col ya que heredan de la clase Node . Y cuando tenga un tipo de retorno diferente de int , tienen que utilizar lo siguiente: SemantErrors . mainFunctionShouldHaveAnIntRetType ( line , col ) Ustedes tienen que agregar los formals al scope que acaban de crear, pero ustedes tienen que verificar que los nombres de los par\u00e1metros no se repitan, por ejemplo esto estar\u00eda incorrecto: def foo ( x : int , x : int ) Cuando suceda lo anterior tienen que utilizar lo siguiente: SemantErrors . formalIsAlreadyDefined ( formal . line , formal . col , formal . name ) Agregar formal Utilicen lo siguiente para agregar el formal al scope actual: O . add ( formal . name , formal . type ) Noten que como valor mandamos el tipo del formal \u00bfPor qu\u00e9? Tipo formal tiene que ser una instancia de la clase Formal Despu\u00e9s deber\u00edan de mandar a llamar recursivamente a semant para los statements y la expresi\u00f3n de retorno ret . Cuando estas dos llamadas regresen si ret no tiene tipo void y la funci\u00f3n si, tienen utilizar lo siguiente para reportar el error: SemantErrors . unexpectedReturnValue ( ret . line , ret . col ) Si ret es void y la funci\u00f3n tiene un tipo de retorno diferente de void utilizar lo siguiente: SemantErrors . missingReturnStatement ( line , col ) Y en general si ret no es igual al tipo de retorno de la funci\u00f3n entonces: SemantErrors . incompatibleTypes ( ret . line , ret . col , ret . getType (), type ) Al finalizar el an\u00e1lisis deber\u00edan de cerrar el scope, para evitar otros errores: O . exitScope ()","title":"An\u00e1lisis de Function"},{"location":"labs/lab06/#constantes","text":"Esto es bastante sencillo, si es una constante entera, el tipo de la expresi\u00f3n es int . Lo mismo pasa con las dem\u00e1s constantes, strings str y booleans bool .","title":"Constantes"},{"location":"labs/lab06/#operaciones-aritmeticas","text":"Primero tienen que mandar a llamar recursivamente a semant de las expresiones que conforman el nodo. Las operaciones aritm\u00e9ticas siempre tienen que tener operandos de tipo int y siempre devuelven como resultado un int . Cuando alg\u00fan operando no sea de tipo int tienen que utilizar el siguiente errror: SemantErrors . badOperandTypesForBinaryOp ( line , col , operator ) Operadores operator tiene que ser un String que represente la operaci\u00f3n binaria, por ejemplo \"+\" Siempre tienen que asumir que el tipo de una expresi\u00f3n aritm\u00e9tica es un int , de lo contrario nos encontrariamos con errores en cascada poco informativos, consideren lo siguiente: true + 2 + 2 + 2 Si no asumieramos lo de arriba pasar\u00eda lo siguiente: bad operand types for binary operator '+' bad operand types for binary operator '+' bad operand types for binary operator '+' A pesar que solo el primer operando de esa serie de sumas es el incorrecto. Lo correcto ser\u00eda desplegar lo siguiente: bad operand types for binary operator '+' Esto es una forma de recuperaci\u00f3n de errores que tambi\u00e9n van a tener que realizar en su proyecto. Vamos a mentir En otras palabras, implementaremos lo visto en clase. Aunque suceda un error, mentiremos y reportaremos que nuestra operaci\u00f3n aritm\u00e9tica tiene tipo Int , esto nos ayuda a que el error no se propague sino que se reporte una sola vez.","title":"Operaciones Aritm\u00e9ticas"},{"location":"labs/lab06/#return","text":"Cuando hagan el an\u00e1lisis sem\u00e1ntico de Return recuerden que el tipo del return es el mismo que el de la expresi\u00f3n e del return.","title":"Return"},{"location":"labs/lab06/#autograder","text":"Para compilar un programa usando el semantic que acaba de implementar, use el comando: sudo ./gradlew build ./run -viper examples/viper/nombreDelArchivo.vp Para correr todas las pruebas, use el comando: sudo ./gradlew build ./check viper Si todo lo tienen bien, les deber\u00eda de salir lo siguiente: Autograder +1 ( unexpectedreturn ) +1 ( diffrettype ) +1 ( arith ) +1 ( mainwithargs ) +1 ( basic ) +1 ( badarith ) +1 ( mainnoint ) +1 ( good ) +1 ( badformals ) +1 ( string ) +1 ( bool ) +1 ( missingret ) = > You got a score of 12 out of 12 . Si necesitara compilar alg\u00fan archivo con nuestro compilador de pruebas puede usar el siguiente comando. Esto le servir\u00e1 principalmente cuando lleguemos a codegen. ./vipercl examples/viper/nombreDelArchivo.vp Luego de haber compilado, use el siguiente comando para ejecutar. ./jupiter runtime/runtime.s examples/viper/nombreDelArchivo.s","title":"Autograder"},{"location":"labs/lab07/","text":"Lab 7 (An\u00e1lisis Sem\u00e1ntico II) \u00b6 En este laboratorio van a continuar con el an\u00e1lisis sem\u00e1ntico del lenguaje Viper y as\u00ed ganar a\u00fan m\u00e1s intuici\u00f3n en esta fase del compilador y que plasmar estas ideas en su proyecto sea bastante sencillo. Antes de empezar, vamos a obtener los archivos necesarios desde Github Classroom: https://classroom.github.com/a/qNKtGDri Lean bien Este lab es m\u00e1s complejo que los anteriores, por favor lean todas las instrucciones del lab, antes de empezar. Reglas de Inferencia \u00b6 Vamos a continuar utilizando el archivo que tiene todas las reglas de inferencia del lenguaje, pueden descargar este archivo aqu\u00ed: Reglas de inferencia de Viper \u00bfQu\u00e9 tienen que hacer? \u00b6 Como se pudieron dar cuenta en el laboratorio pasado en src/viper/tree est\u00e1n definidos los nodos que representan el AST de Viper. En este laboratorio ustedes tienen que completar los 10 nodos restantes, estos nodos son los siguientes: Assign Call Declaration Equal Id If LessEqual LessThan Not While Lab anterior Ustedes tienen que copiar lo que implementaron en el laboratorio pasado, de lo contrario el autograder no les dar\u00e1 todos los puntos, simplemente tienen que copiar y reemplazar los archivos. Para algunos de estos nodos como LessEqual , LessThan , Not su c\u00f3digo deber\u00eda de ser bastante similar a lo que hicieron con las operaciones artim\u00e9ticas, incluso para Equal , solo que aqu\u00ed tenemos la restricci\u00f3n que ambos operandos tienen que ser del mismo tipo ya sea int , bool o str . Para los dem\u00e1s nodos si van a tener que hacer un par de cosas m\u00e1s. Para que tengan una referencia de que tanto tendr\u00edan que agregar a los diferentes archivos, aqu\u00ed est\u00e1n las estad\u00edsticas de nuestra implementaci\u00f3n: src/viper/tree/Assign.java | 12 +++++++++++- src/viper/tree/Call.java | 22 +++++++++++++++++++++- src/viper/tree/Declaration.java | 10 +++++++++- src/viper/tree/Equal.java | 7 ++++++- src/viper/tree/Id.java | 8 +++++++- src/viper/tree/If.java | 11 ++++++++++- src/viper/tree/LessEqual.java | 7 ++++++- src/viper/tree/LessThan.java | 7 ++++++- src/viper/tree/Not.java | 6 +++++- src/viper/tree/While.java | 8 +++++++- 10 files changed, 88 insertions ( + ) , 10 deletions ( - ) Implementaci\u00f3n \u00b6 Para cada nodo del AST hay una serie de pasos que se tienen que realizar para garantizar que el an\u00e1lisis sem\u00e1ntico capture todos los errores posibles, recuerden que esta es nuestra \u00faltima barrera antes de codegen para atrapar errores. Assign \u00b6 Para el assign primero deben llamar recursivamente a semant de e . Luego verificar que la variable a la se se le est\u00e1 asignando un valor exista en alg\u00fan scope, si esta variable no existe deber\u00edan devolver el siguiente error e indicar que el tipo de la expresi\u00f3n es void . SemantErrors . cannotFindSymbol ( line , col , name ); void En general cuando no se pueda recuperar del error y no se le pueda asignar un tipo a una expresi\u00f3n, el tipo de la expresi\u00f3n ser\u00e1 void . En el proyecto haremos algo similar con Object . Si la variable a la que se le est\u00e1 asignando un valor existe, pero tiene un tipo diferente que el de la expresi\u00f3n, deber\u00edan de devolver el siguiente error: SemantErrors . incompatibleTypes ( e . line , e . col , e . getType (), t ); // t deber\u00eda de ser el tipo que devolvio su entorno O Como en este error si se pueden recuperar porque si saben cual es el tipo de la variable, tienen que poner que el tipo del nodo es el tipo de la variable. Si ambos tipos coinciden de igual forma tienen que indicar que el tipo del nodo es el tipo de la variable. Call \u00b6 El an\u00e1lisis sem\u00e1ntico de Call es lo m\u00e1s complicado que realizar\u00e1n en este laboratorio, primero deber\u00edan llamar recursivamente a semant de cada actual que tenga el nodo, y atrapar sus errores. Luego si la funci\u00f3n que se est\u00e1 mandando a llamar no existe deber\u00edan de devolver el siguiente error e indicar que el tipo es void : SemantErrors . cannotFindSymbol ( line , col , name ); O Van a encontrar \u00fatil el entorno O en esta parte del laboratorio. Si la funci\u00f3n si existe, ustedes deber\u00edan verificar que la cantidad de argumentos (actuals) sea igual a la cantidad de par\u00e1metros formales, si no es as\u00ed devolver el siguiente error: SemantErrors . functionCalledWithWrongNumberOfArgs ( line , col , name ); Si ocurre este error todav\u00eda es posible recuperarse del error porque sabemos el tipo de retorno de la funci\u00f3n, entonces tienen que indicar que el tipo del nodo es el tipo de retorno de la expresi\u00f3n. Por \u00faltimo (si el tama\u00f1o de actuals es igual al de los formals) deber\u00edan de verificar que cada actual sea del mismo tipo, si no es as\u00ed indicar el siguiente error: SemantErrors . incompatibleTypes ( e . line , e . col , e . getType (), f . type ); Tipo de retorno Siempre que sepan que la funci\u00f3n existe, el tipo del nodo deber\u00eda de ser igual al tipo de retorno de la funci\u00f3n. Declaration \u00b6 Como este nodo no es una expresi\u00f3n, no es necesario anotarlo con un tipo, de todos modos es necesario hacerle su respectivo an\u00e1lisis sem\u00e1ntico. Primero deber\u00edan de comenzar llamando recursivamente a semant de init . Luego verificar que la variable no haya sido declarada ya en el scope actual, si ya existe indicar el siguiente error: SemantErrors . variableIsAlreadyDefined ( line , col , name ); Shadowing El error anterior solo deber\u00eda ocurrir si la variable es declarada m\u00e1s de una vez en el scope actual, algo como esto: def foo ( x : int ): void { int x = 10 ; } y no en el siguiente caso: def foo ( x : int ): void { int y = 10 ; while ( true ) { int y = 20 ; } } ya que el lenguaje Viper , lastimosamente, permite shadowing como en el lenguage COOL y otros lenguajes populares como java o C . \u00bfQu\u00e9 m\u00e9todo de O les conviene m\u00e1s utilizar?. Si no es el caso que la variable est\u00e1 declarada m\u00e1s de una vez en el scope actual, deber\u00edan de agregarla a este. Recuerden que lo que nos interesa guardar de las variables en O es el tipo y nada m\u00e1s. Por \u00faltimo verificar que el tipo de init sea el mismo tipo que el tipo declarado, de lo contrario indicar el siguiente error: SemantErrors . incompatibleTypes ( init . line , init . col , init . getType (), type ); Equal \u00b6 Para este nodo tienen que hacer algo similar a lo que hicieron en las expresiones aritm\u00e9ticas, llamar recursivamente a semant de cada operando, en este caso ambos operandos tienen que ser del mismo tipo para poderse comparar, si no indicar el siguiente error: SemantErrors . incomparableTypes ( line , col , e1 . getType (), e2 . getType ()); Si este error sucede es f\u00e1cil recuperarse porque sabemos que el tipo que devuelve una comparaci\u00f3n siempre es bool , deber\u00edan de anotar este nodo con el tipo bool . LessEqual, LessThan \u00b6 Lo mismo que Equal , lo \u00fanico que cambia aqu\u00ed es que ambos operandos del nodo tienen que ser de tipo int , si alguno no lo es indicar el siguiente error: SemantErrors . badOperandTypesForBinaryOp ( line , col , operator ); // cambien operator con el operador del nodo, i.e, <= o < No se olviden anotar el nodo con el tipo bool. Id \u00b6 Este es nodo es bastante f\u00e1cil, unicamente tienen que buscar en el entorno O si la variable existe en alg\u00fan scope si no existe indicar el siguiente error y anotar el nodo con void : SemantErrors . cannotFindSymbol ( line , col , name ); Si la variable existe, anotar el nodo con el tipo que nos indica O . If \u00b6 Para el if ustedes deber\u00edan de mandar a llamar recursivamente a semant de pred verificar si este es de tipo bool y si no lo es indicar el siguiente error: SemantErrors . incompatibleTypes ( pred . line , pred . col , pred . getType (), Type . BOOL ); Luego mandar a llamar recursivamente a semant de thenp y luego elsep , recuerden que en Viper cada par de llaves {} abre un scope nuevo. Nuevamente este nodo no es una expresi\u00f3n entonces no es necesario anotarlo. Scope nuevo Cuando nos referimos a que se abre un scope nuevo, su c\u00f3digo deber\u00eda de verse algo as\u00ed: O . enterScope (); // analisis semantico de algo O . exitScope () While \u00b6 El while es muy similar al if , tienen que llamar recursivamente de cond , verificar que sea de tipo bool , si no lo es indicar el siguiente error: SemantErrors . incompatibleTypes ( cond . line , cond . col , cond . getType (), Type . BOOL ); Luego mandar a llamar recursivamente a body , nuevamente abriendo un scope nuevo. Nuevamente este nodo no es una expresi\u00f3n entonces no es necesario anotarlo. Autograder \u00b6 Para probar su implementaci\u00f3n pueden utitlizar lo siguiente: sudo ./gradlew build ./check Si todo lo tienen bien, les deber\u00eda de salir lo siguiente: Autograder +1 ( badassign2 ) +1 ( compare ) +1 ( unexpectedreturn ) +1 ( diffrettype ) +1 ( call ) +1 ( arith ) +1 ( mainwithargs ) +1 ( baddecl2 ) +1 ( badid ) +1 ( fact ) +1 ( basic ) +1 ( badarith ) +1 ( if ) +1 ( mainnoint ) +1 ( badcall2 ) +1 ( badcall3 ) +1 ( id ) +1 ( badassign ) +1 ( good ) +1 ( while ) +1 ( assign ) +1 ( shadowing ) +1 ( badif ) +1 ( badcall1 ) +1 ( badformals ) +1 ( badequal ) +1 ( decl ) +1 ( string ) +1 ( badwhile ) +1 ( nomain ) +1 ( bool ) +1 ( equal ) +1 ( missingret ) +1 ( baddecl1 ) +1 ( badcompare ) = > You got a score of 35 out of 35 . Si ustedes desean probar en un archivo en espec\u00edfico pueden hacer lo siguiente: sudo ./gradlew build ./run <archivo> En la carpeta examples/ hay algunos ejemplos para que puedan probar. \u00a1LISTO! Han terminado el an\u00e1lisis sem\u00e1ntico de Viper , es hora de lograr terminar el an\u00e1lisis sem\u00e1ntico de COOL , esperamos que esta serie de laboratorios les hayan ayudado bastante.","title":"7: Semantic 2"},{"location":"labs/lab07/#lab-7-40analisis-semantico-ii41","text":"En este laboratorio van a continuar con el an\u00e1lisis sem\u00e1ntico del lenguaje Viper y as\u00ed ganar a\u00fan m\u00e1s intuici\u00f3n en esta fase del compilador y que plasmar estas ideas en su proyecto sea bastante sencillo. Antes de empezar, vamos a obtener los archivos necesarios desde Github Classroom: https://classroom.github.com/a/qNKtGDri Lean bien Este lab es m\u00e1s complejo que los anteriores, por favor lean todas las instrucciones del lab, antes de empezar.","title":"Lab 7 (An\u00e1lisis Sem\u00e1ntico II)"},{"location":"labs/lab07/#reglas-de-inferencia","text":"Vamos a continuar utilizando el archivo que tiene todas las reglas de inferencia del lenguaje, pueden descargar este archivo aqu\u00ed: Reglas de inferencia de Viper","title":"Reglas de Inferencia"},{"location":"labs/lab07/#que-tienen-que-hacer","text":"Como se pudieron dar cuenta en el laboratorio pasado en src/viper/tree est\u00e1n definidos los nodos que representan el AST de Viper. En este laboratorio ustedes tienen que completar los 10 nodos restantes, estos nodos son los siguientes: Assign Call Declaration Equal Id If LessEqual LessThan Not While Lab anterior Ustedes tienen que copiar lo que implementaron en el laboratorio pasado, de lo contrario el autograder no les dar\u00e1 todos los puntos, simplemente tienen que copiar y reemplazar los archivos. Para algunos de estos nodos como LessEqual , LessThan , Not su c\u00f3digo deber\u00eda de ser bastante similar a lo que hicieron con las operaciones artim\u00e9ticas, incluso para Equal , solo que aqu\u00ed tenemos la restricci\u00f3n que ambos operandos tienen que ser del mismo tipo ya sea int , bool o str . Para los dem\u00e1s nodos si van a tener que hacer un par de cosas m\u00e1s. Para que tengan una referencia de que tanto tendr\u00edan que agregar a los diferentes archivos, aqu\u00ed est\u00e1n las estad\u00edsticas de nuestra implementaci\u00f3n: src/viper/tree/Assign.java | 12 +++++++++++- src/viper/tree/Call.java | 22 +++++++++++++++++++++- src/viper/tree/Declaration.java | 10 +++++++++- src/viper/tree/Equal.java | 7 ++++++- src/viper/tree/Id.java | 8 +++++++- src/viper/tree/If.java | 11 ++++++++++- src/viper/tree/LessEqual.java | 7 ++++++- src/viper/tree/LessThan.java | 7 ++++++- src/viper/tree/Not.java | 6 +++++- src/viper/tree/While.java | 8 +++++++- 10 files changed, 88 insertions ( + ) , 10 deletions ( - )","title":"\u00bfQu\u00e9 tienen que hacer?"},{"location":"labs/lab07/#implementacion","text":"Para cada nodo del AST hay una serie de pasos que se tienen que realizar para garantizar que el an\u00e1lisis sem\u00e1ntico capture todos los errores posibles, recuerden que esta es nuestra \u00faltima barrera antes de codegen para atrapar errores.","title":"Implementaci\u00f3n"},{"location":"labs/lab07/#assign","text":"Para el assign primero deben llamar recursivamente a semant de e . Luego verificar que la variable a la se se le est\u00e1 asignando un valor exista en alg\u00fan scope, si esta variable no existe deber\u00edan devolver el siguiente error e indicar que el tipo de la expresi\u00f3n es void . SemantErrors . cannotFindSymbol ( line , col , name ); void En general cuando no se pueda recuperar del error y no se le pueda asignar un tipo a una expresi\u00f3n, el tipo de la expresi\u00f3n ser\u00e1 void . En el proyecto haremos algo similar con Object . Si la variable a la que se le est\u00e1 asignando un valor existe, pero tiene un tipo diferente que el de la expresi\u00f3n, deber\u00edan de devolver el siguiente error: SemantErrors . incompatibleTypes ( e . line , e . col , e . getType (), t ); // t deber\u00eda de ser el tipo que devolvio su entorno O Como en este error si se pueden recuperar porque si saben cual es el tipo de la variable, tienen que poner que el tipo del nodo es el tipo de la variable. Si ambos tipos coinciden de igual forma tienen que indicar que el tipo del nodo es el tipo de la variable.","title":"Assign"},{"location":"labs/lab07/#call","text":"El an\u00e1lisis sem\u00e1ntico de Call es lo m\u00e1s complicado que realizar\u00e1n en este laboratorio, primero deber\u00edan llamar recursivamente a semant de cada actual que tenga el nodo, y atrapar sus errores. Luego si la funci\u00f3n que se est\u00e1 mandando a llamar no existe deber\u00edan de devolver el siguiente error e indicar que el tipo es void : SemantErrors . cannotFindSymbol ( line , col , name ); O Van a encontrar \u00fatil el entorno O en esta parte del laboratorio. Si la funci\u00f3n si existe, ustedes deber\u00edan verificar que la cantidad de argumentos (actuals) sea igual a la cantidad de par\u00e1metros formales, si no es as\u00ed devolver el siguiente error: SemantErrors . functionCalledWithWrongNumberOfArgs ( line , col , name ); Si ocurre este error todav\u00eda es posible recuperarse del error porque sabemos el tipo de retorno de la funci\u00f3n, entonces tienen que indicar que el tipo del nodo es el tipo de retorno de la expresi\u00f3n. Por \u00faltimo (si el tama\u00f1o de actuals es igual al de los formals) deber\u00edan de verificar que cada actual sea del mismo tipo, si no es as\u00ed indicar el siguiente error: SemantErrors . incompatibleTypes ( e . line , e . col , e . getType (), f . type ); Tipo de retorno Siempre que sepan que la funci\u00f3n existe, el tipo del nodo deber\u00eda de ser igual al tipo de retorno de la funci\u00f3n.","title":"Call"},{"location":"labs/lab07/#declaration","text":"Como este nodo no es una expresi\u00f3n, no es necesario anotarlo con un tipo, de todos modos es necesario hacerle su respectivo an\u00e1lisis sem\u00e1ntico. Primero deber\u00edan de comenzar llamando recursivamente a semant de init . Luego verificar que la variable no haya sido declarada ya en el scope actual, si ya existe indicar el siguiente error: SemantErrors . variableIsAlreadyDefined ( line , col , name ); Shadowing El error anterior solo deber\u00eda ocurrir si la variable es declarada m\u00e1s de una vez en el scope actual, algo como esto: def foo ( x : int ): void { int x = 10 ; } y no en el siguiente caso: def foo ( x : int ): void { int y = 10 ; while ( true ) { int y = 20 ; } } ya que el lenguaje Viper , lastimosamente, permite shadowing como en el lenguage COOL y otros lenguajes populares como java o C . \u00bfQu\u00e9 m\u00e9todo de O les conviene m\u00e1s utilizar?. Si no es el caso que la variable est\u00e1 declarada m\u00e1s de una vez en el scope actual, deber\u00edan de agregarla a este. Recuerden que lo que nos interesa guardar de las variables en O es el tipo y nada m\u00e1s. Por \u00faltimo verificar que el tipo de init sea el mismo tipo que el tipo declarado, de lo contrario indicar el siguiente error: SemantErrors . incompatibleTypes ( init . line , init . col , init . getType (), type );","title":"Declaration"},{"location":"labs/lab07/#equal","text":"Para este nodo tienen que hacer algo similar a lo que hicieron en las expresiones aritm\u00e9ticas, llamar recursivamente a semant de cada operando, en este caso ambos operandos tienen que ser del mismo tipo para poderse comparar, si no indicar el siguiente error: SemantErrors . incomparableTypes ( line , col , e1 . getType (), e2 . getType ()); Si este error sucede es f\u00e1cil recuperarse porque sabemos que el tipo que devuelve una comparaci\u00f3n siempre es bool , deber\u00edan de anotar este nodo con el tipo bool .","title":"Equal"},{"location":"labs/lab07/#lessequal-lessthan","text":"Lo mismo que Equal , lo \u00fanico que cambia aqu\u00ed es que ambos operandos del nodo tienen que ser de tipo int , si alguno no lo es indicar el siguiente error: SemantErrors . badOperandTypesForBinaryOp ( line , col , operator ); // cambien operator con el operador del nodo, i.e, <= o < No se olviden anotar el nodo con el tipo bool.","title":"LessEqual, LessThan"},{"location":"labs/lab07/#id","text":"Este es nodo es bastante f\u00e1cil, unicamente tienen que buscar en el entorno O si la variable existe en alg\u00fan scope si no existe indicar el siguiente error y anotar el nodo con void : SemantErrors . cannotFindSymbol ( line , col , name ); Si la variable existe, anotar el nodo con el tipo que nos indica O .","title":"Id"},{"location":"labs/lab07/#if","text":"Para el if ustedes deber\u00edan de mandar a llamar recursivamente a semant de pred verificar si este es de tipo bool y si no lo es indicar el siguiente error: SemantErrors . incompatibleTypes ( pred . line , pred . col , pred . getType (), Type . BOOL ); Luego mandar a llamar recursivamente a semant de thenp y luego elsep , recuerden que en Viper cada par de llaves {} abre un scope nuevo. Nuevamente este nodo no es una expresi\u00f3n entonces no es necesario anotarlo. Scope nuevo Cuando nos referimos a que se abre un scope nuevo, su c\u00f3digo deber\u00eda de verse algo as\u00ed: O . enterScope (); // analisis semantico de algo O . exitScope ()","title":"If"},{"location":"labs/lab07/#while","text":"El while es muy similar al if , tienen que llamar recursivamente de cond , verificar que sea de tipo bool , si no lo es indicar el siguiente error: SemantErrors . incompatibleTypes ( cond . line , cond . col , cond . getType (), Type . BOOL ); Luego mandar a llamar recursivamente a body , nuevamente abriendo un scope nuevo. Nuevamente este nodo no es una expresi\u00f3n entonces no es necesario anotarlo.","title":"While"},{"location":"labs/lab07/#autograder","text":"Para probar su implementaci\u00f3n pueden utitlizar lo siguiente: sudo ./gradlew build ./check Si todo lo tienen bien, les deber\u00eda de salir lo siguiente: Autograder +1 ( badassign2 ) +1 ( compare ) +1 ( unexpectedreturn ) +1 ( diffrettype ) +1 ( call ) +1 ( arith ) +1 ( mainwithargs ) +1 ( baddecl2 ) +1 ( badid ) +1 ( fact ) +1 ( basic ) +1 ( badarith ) +1 ( if ) +1 ( mainnoint ) +1 ( badcall2 ) +1 ( badcall3 ) +1 ( id ) +1 ( badassign ) +1 ( good ) +1 ( while ) +1 ( assign ) +1 ( shadowing ) +1 ( badif ) +1 ( badcall1 ) +1 ( badformals ) +1 ( badequal ) +1 ( decl ) +1 ( string ) +1 ( badwhile ) +1 ( nomain ) +1 ( bool ) +1 ( equal ) +1 ( missingret ) +1 ( baddecl1 ) +1 ( badcompare ) = > You got a score of 35 out of 35 . Si ustedes desean probar en un archivo en espec\u00edfico pueden hacer lo siguiente: sudo ./gradlew build ./run <archivo> En la carpeta examples/ hay algunos ejemplos para que puedan probar. \u00a1LISTO! Han terminado el an\u00e1lisis sem\u00e1ntico de Viper , es hora de lograr terminar el an\u00e1lisis sem\u00e1ntico de COOL , esperamos que esta serie de laboratorios les hayan ayudado bastante.","title":"Autograder"},{"location":"labs/lab08/","text":"Lab 8 (RISC-V) \u00b6 En este laboratorio van a programar en lenguaje ensamblador para practicar y reforzar los conocimientos que adquirieron durante CC3. Antes de empezar, vamos a obtener los archivos necesarios desde Github Classroom: https://classroom.github.com/a/XEqsO7p_ Jupiter \u00b6 Si est\u00e1 utilizando un Linux distinto al nuestro, instale Jupiter: sudo add-apt-repository ppa:andrescv/jupiter sudo apt-get update sudo apt-get install jupiter Pueden correr Jupiter de forma gr\u00e1fica utilizando lo siguiente: jupiter o en modo l\u00ednea de comandos utilizando lo siguiente: jupiter [ options ] <files> las opciones disponibles son las siguientes: [ General Options ] -h, --help show Jupiter help message and exit -v, --version show Jupiter version -l, --license show Jupiter license [ Simulator Options ] -b, --bare bare machine ( no pseudo-instructions ) -s, --self enable self-modifying code -e, --extrict assembler warnings are consider errors -g, --debug start debugger --start <label> set global start label ( default: __start ) --hist <size> history size for debugging [ Cache Options ] -c, --cache enable cache simulation --assoc <assoc> cache associativity as a power of 2 ( default: 1 ) --block-size <size> cache block size as a power of 2 ( default: 16 ) --num-blocks <num> number of cache blocks as a power of 2 ( default: 4 ) --policy <policy> cache block replace policy ( LRU | FIFO | RAND ) ( default: LRU ) [ Dump Options ] --dump-code <file> dump generated machine code to a file --dump-data <file> dump static data to a file La documentaci\u00f3n de Jupiter la pueden encontrar en el siguiente link . Detalles de RISC-V \u00b6 Los programas de RISC-V van en un archivo de texto con extension .s . Los programas deber\u00edan de llevar un label global __start que se utilizar\u00e1 como punto de inicio. Los programas deber\u00edan de terminar de la siguiente manera: li a0 , 10 # codigo 10: exit ecall # llamada al entorno Las etiquetas o labels terminal con dos puntos. Los comentarios comienzan con un numeral o con punto y coma. No pueden poner m\u00e1s de una instrucci\u00f3n por l\u00ednea. Recordatorio de Assembler \u00b6 Uno de los requisitos de CC4 es dominar los temas de CC3, incluyendo programar en lenguaje ensamblador. RISC-V es una arquitectura RISC por lo cual es muy f\u00e1cil de utilizar. Algunas instrucciones que deber\u00edan conocer hasta el momento son: # carga el contenido de memoria en la direccion (pc + 8) y lo guarda en t1 lw t1 , 8 ( sp ) # guarda a0 en memoria en la direccion (pc + 8) sw a0 , 8 ( sp ) # guarda el inmediato 5 en el registro t1 li t1 , 5 # guarda la direccion de foo en el registro t1 la t1 , foo # suma los registros t1 y t2 y el resultado lo guarda en t3 add t3 , t1 , t2 # suma el registro sp con el inmediato 4 y guarda el resultado en sp addi sp , sp , 4 # salta a la etiqueta label j label # salta a la etiqueta label y guarda en el registro ra PC + 4 jal label # salta a la direccion contenida en el registro ra jr ra # si t1 y t2 son iguales, realizar salto hacia foo beq t1 , t2 , foo Cuando realizamos llamadas a funciones en assembler debemos ser cuidadosos de no perder las direcciones de retorno. Este y otros datos deben ser guardados en el stack al inicio de la llamada y restaurados cuando esta termina. El convenio de RISC-V es el siguiente: Los registros aX se utilizan como argumentos cuando se manda a llamar a una funci\u00f3n. Los registros aX se utilizan como valores de retorno de las funciones. Los registros tX se utilizan como temporales, cuyo valor puede perderse entre llamadas. Los registros sX sobreviven a llamadas. El registro sp es el puntero hacia el stack. El registro ra contiene la direcci\u00f3n de retorno (pc + 4). Veamos un ejemplo sencillo de un ciclo en RISC-V: . text . globl __start # indicamos que __start es global y punto de partida __start : li t0 , 0 # i li t1 , 10 # max cond : bge t0 , t1 , endLoop # terminamos si i >= max body : mv a1 , t0 # movemos t0 a a1 para imprimirlo li a0 , 1 # codigo ecall para imprimir un entero ecall # imprimimos i step : addi t0 , t0 , 1 # step del loop j cond # salto hacia la condicion endLoop : li a0 , 10 # codigo ecall para salir de un programa ecall # salimos del programa Veamos ahora un programa con llamadas recursivas: . rodata msg : . string \"El resultado es: \" . text . globl __start # indicamos que __start es global y punto de partida __start : li a0 , 5 # queremos calcular factorial de 5 jal factorial # llamamos a factorial mv s0 , a0 # guardamos el resultado en s0 la a1 , msg # cargamos la direccion de msg en a1 li a0 , 4 # codigo ecall para imprimir un string ecall # imprimimos el string mv a1 , s0 # movemos s0 a a1 (que tenia el resultado de factorial) li a0 , 1 # codigo ecall para imprimir un entero ecall # imprimimos el entero li a0 , 10 # codigo ecall para salir del programa ecall # salimos del programa factorial : # a0 trae el resultado # ra tiene la direccion de retorno # sp apunta hacia el tope del stack bne a0 , x0 , notZero # si a0 != 0 saltar a notZero li a0 , 1 # de lo contrario devolver 1 jr ra # saltar a la direccion de retorno notZero : addi sp , sp , - 8 # protegemos algunos valores en el stack (2 words) sw s0 , 0 ( sp ) # guardamos s0 porque lo vamos a utilizar en la funcion sw ra , 4 ( sp ) # guardamos ra para no perder la direccion de retorno mv s0 , a0 # guardamos a0 en s0 para no perderlo addi a0 , a0 , - 1 # decrementamos a0 para la siguiente llamada: fact(n - 1) jal factorial # llamamos recursivamente a factorial mul a0 , a0 , s0 # efectuamos n * fact(n - 1) lw s0 , 0 ( sp ) # restauramos s0 lw ra , 4 ( sp ) # restauramos ra addi sp , sp , 8 # liberamos el espacio jr ra # saltamos a la direccion de retorno Ejercicio 1: fibonacci.s \u00b6 En un archivo llamado fibonacci.s implementen la funci\u00f3n de fibonacci en lenguaje ensamblador RISC-V. Ejercicio 2: hanoi.s \u00b6 Otra funci\u00f3n recursiva, traduzca a RISC-V el siguiente c\u00f3digo que sirve para resolver el juego de torres de Hanoi. void hanoi ( int numeroDeDiscos , int T_origen , int T_destino , int T_alterna ) { if ( numerodeDiscos == 1 ) { printf ( \"mueva el disco de la torre: \" ); printf ( \"%i\" , T_origen ); printf ( \" hacia la torre: \" ); printf ( \"%i \\n \" , T_destino ); } else { hanoi ( numeroDeDiscos - 1 , T_origen , T_alterna , T_destino ); hanoi ( 1 , T_origen , T_destino , T_alterna ); hanoi ( numeroDeDiscos - 1 , T_alterna , T_destino , T_origen ); } }","title":"8: RISC-V"},{"location":"labs/lab08/#lab-8-40risc-v41","text":"En este laboratorio van a programar en lenguaje ensamblador para practicar y reforzar los conocimientos que adquirieron durante CC3. Antes de empezar, vamos a obtener los archivos necesarios desde Github Classroom: https://classroom.github.com/a/XEqsO7p_","title":"Lab 8 (RISC-V)"},{"location":"labs/lab08/#jupiter","text":"Si est\u00e1 utilizando un Linux distinto al nuestro, instale Jupiter: sudo add-apt-repository ppa:andrescv/jupiter sudo apt-get update sudo apt-get install jupiter Pueden correr Jupiter de forma gr\u00e1fica utilizando lo siguiente: jupiter o en modo l\u00ednea de comandos utilizando lo siguiente: jupiter [ options ] <files> las opciones disponibles son las siguientes: [ General Options ] -h, --help show Jupiter help message and exit -v, --version show Jupiter version -l, --license show Jupiter license [ Simulator Options ] -b, --bare bare machine ( no pseudo-instructions ) -s, --self enable self-modifying code -e, --extrict assembler warnings are consider errors -g, --debug start debugger --start <label> set global start label ( default: __start ) --hist <size> history size for debugging [ Cache Options ] -c, --cache enable cache simulation --assoc <assoc> cache associativity as a power of 2 ( default: 1 ) --block-size <size> cache block size as a power of 2 ( default: 16 ) --num-blocks <num> number of cache blocks as a power of 2 ( default: 4 ) --policy <policy> cache block replace policy ( LRU | FIFO | RAND ) ( default: LRU ) [ Dump Options ] --dump-code <file> dump generated machine code to a file --dump-data <file> dump static data to a file La documentaci\u00f3n de Jupiter la pueden encontrar en el siguiente link .","title":"Jupiter"},{"location":"labs/lab08/#detalles-de-risc-v","text":"Los programas de RISC-V van en un archivo de texto con extension .s . Los programas deber\u00edan de llevar un label global __start que se utilizar\u00e1 como punto de inicio. Los programas deber\u00edan de terminar de la siguiente manera: li a0 , 10 # codigo 10: exit ecall # llamada al entorno Las etiquetas o labels terminal con dos puntos. Los comentarios comienzan con un numeral o con punto y coma. No pueden poner m\u00e1s de una instrucci\u00f3n por l\u00ednea.","title":"Detalles de RISC-V"},{"location":"labs/lab08/#recordatorio-de-assembler","text":"Uno de los requisitos de CC4 es dominar los temas de CC3, incluyendo programar en lenguaje ensamblador. RISC-V es una arquitectura RISC por lo cual es muy f\u00e1cil de utilizar. Algunas instrucciones que deber\u00edan conocer hasta el momento son: # carga el contenido de memoria en la direccion (pc + 8) y lo guarda en t1 lw t1 , 8 ( sp ) # guarda a0 en memoria en la direccion (pc + 8) sw a0 , 8 ( sp ) # guarda el inmediato 5 en el registro t1 li t1 , 5 # guarda la direccion de foo en el registro t1 la t1 , foo # suma los registros t1 y t2 y el resultado lo guarda en t3 add t3 , t1 , t2 # suma el registro sp con el inmediato 4 y guarda el resultado en sp addi sp , sp , 4 # salta a la etiqueta label j label # salta a la etiqueta label y guarda en el registro ra PC + 4 jal label # salta a la direccion contenida en el registro ra jr ra # si t1 y t2 son iguales, realizar salto hacia foo beq t1 , t2 , foo Cuando realizamos llamadas a funciones en assembler debemos ser cuidadosos de no perder las direcciones de retorno. Este y otros datos deben ser guardados en el stack al inicio de la llamada y restaurados cuando esta termina. El convenio de RISC-V es el siguiente: Los registros aX se utilizan como argumentos cuando se manda a llamar a una funci\u00f3n. Los registros aX se utilizan como valores de retorno de las funciones. Los registros tX se utilizan como temporales, cuyo valor puede perderse entre llamadas. Los registros sX sobreviven a llamadas. El registro sp es el puntero hacia el stack. El registro ra contiene la direcci\u00f3n de retorno (pc + 4). Veamos un ejemplo sencillo de un ciclo en RISC-V: . text . globl __start # indicamos que __start es global y punto de partida __start : li t0 , 0 # i li t1 , 10 # max cond : bge t0 , t1 , endLoop # terminamos si i >= max body : mv a1 , t0 # movemos t0 a a1 para imprimirlo li a0 , 1 # codigo ecall para imprimir un entero ecall # imprimimos i step : addi t0 , t0 , 1 # step del loop j cond # salto hacia la condicion endLoop : li a0 , 10 # codigo ecall para salir de un programa ecall # salimos del programa Veamos ahora un programa con llamadas recursivas: . rodata msg : . string \"El resultado es: \" . text . globl __start # indicamos que __start es global y punto de partida __start : li a0 , 5 # queremos calcular factorial de 5 jal factorial # llamamos a factorial mv s0 , a0 # guardamos el resultado en s0 la a1 , msg # cargamos la direccion de msg en a1 li a0 , 4 # codigo ecall para imprimir un string ecall # imprimimos el string mv a1 , s0 # movemos s0 a a1 (que tenia el resultado de factorial) li a0 , 1 # codigo ecall para imprimir un entero ecall # imprimimos el entero li a0 , 10 # codigo ecall para salir del programa ecall # salimos del programa factorial : # a0 trae el resultado # ra tiene la direccion de retorno # sp apunta hacia el tope del stack bne a0 , x0 , notZero # si a0 != 0 saltar a notZero li a0 , 1 # de lo contrario devolver 1 jr ra # saltar a la direccion de retorno notZero : addi sp , sp , - 8 # protegemos algunos valores en el stack (2 words) sw s0 , 0 ( sp ) # guardamos s0 porque lo vamos a utilizar en la funcion sw ra , 4 ( sp ) # guardamos ra para no perder la direccion de retorno mv s0 , a0 # guardamos a0 en s0 para no perderlo addi a0 , a0 , - 1 # decrementamos a0 para la siguiente llamada: fact(n - 1) jal factorial # llamamos recursivamente a factorial mul a0 , a0 , s0 # efectuamos n * fact(n - 1) lw s0 , 0 ( sp ) # restauramos s0 lw ra , 4 ( sp ) # restauramos ra addi sp , sp , 8 # liberamos el espacio jr ra # saltamos a la direccion de retorno","title":"Recordatorio de Assembler"},{"location":"labs/lab08/#ejercicio-1-fibonaccis","text":"En un archivo llamado fibonacci.s implementen la funci\u00f3n de fibonacci en lenguaje ensamblador RISC-V.","title":"Ejercicio 1: fibonacci.s"},{"location":"labs/lab08/#ejercicio-2-hanois","text":"Otra funci\u00f3n recursiva, traduzca a RISC-V el siguiente c\u00f3digo que sirve para resolver el juego de torres de Hanoi. void hanoi ( int numeroDeDiscos , int T_origen , int T_destino , int T_alterna ) { if ( numerodeDiscos == 1 ) { printf ( \"mueva el disco de la torre: \" ); printf ( \"%i\" , T_origen ); printf ( \" hacia la torre: \" ); printf ( \"%i \\n \" , T_destino ); } else { hanoi ( numeroDeDiscos - 1 , T_origen , T_alterna , T_destino ); hanoi ( 1 , T_origen , T_destino , T_alterna ); hanoi ( numeroDeDiscos - 1 , T_alterna , T_destino , T_origen ); } }","title":"Ejercicio 2: hanoi.s"},{"location":"labs/lab09/","text":"Lab 9 (CodeGen I) \u00b6 En este laboratorio van a generar c\u00f3digo en lenguaje ensamblador RISC-V para algunos nodos del lenguaje Viper que utilizar\u00f3n en el laboratorio 6 y 7. Debido a que este lenguaje no es orientado a objetos es m\u00e1s f\u00e1cil generar c\u00f3digo. Los archivos necesarios para este laboratorio los pueden encontrar en el siguiente enlace: https://classroom.github.com/a/dVwKmUVB Los archivos base tienen la misma estructura que vieron anteriormente en los laboratorios 6 y 7. Para este laboratorio el an\u00e1lisis sem\u00e1ntico ya est\u00e1 hecho, as\u00ed que no se tienen que preocupar de esta tarea, solamente se tienen que enfocar en generar c\u00f3digo implementando un Accumulator Machine . Lean bien Este lab es m\u00e1s complejo que los anteriores, por favor lean todas las instrucciones del lab, antes de empezar. Activation Record \u00b6 El activation record para las funciones de Viper es muy similar al que tienen que utilizar para los m\u00e9todos de COOL. Si tuvieramos la siguiente funci\u00f3n de Viper def foo ( x : int , y : int ): void { int var = 10 ; print ( var + x + y ); } El activation record ser\u00eda el siguiente: Soporte \u00b6 Tanto en el proyecto, como en este laboratorio, van a encontrar una clase de ayuda llamada CgenSupport.java que contiene algunas definiciones que sirven para generar c\u00f3digo, revisen esta clase para hacerse una idea de lo que pueden hacer con ella. Aplicar ingenier\u00eda inversa es factible, siempre y cuando tengamos claro que est\u00e1 sucediendo. Utilizando el siguiente comando podemos compilar un archivo y ver lo que el generador de c\u00f3digo ya hecho genera, para que podamos imitar ese comportamiento. ./vipercl <archivo> Para compilar un archivo, utilizando su propio generador de c\u00f3digo pueden hacer lo siguiente. ./compile <archivo> Pueden correr un programa compilado utilizando lo siguiente. ./run <archivo> Generando C\u00f3digo \u00b6 Ustedes tienen que generar c\u00f3digo para los siguientes nodos de Viper: Function Call BoolConst IntConst StrConst Add Sub Div Mod Mul Return Cada nodo de Viper tiene un m\u00e9todo code con la siguiente firma: public void code ( Counter locals , SymbolTable O , PrintStream p ) Los par\u00e1metros tienen el siguiente significado: locals : un contador que nos ayuda a saber cual es el siguiente espacio disponible en el \u00e1rea de variables locales dentro del activation record en relaci\u00f3n al frame pointer (no se utilizar\u00e1 en este laboratorio). O : Es nuestra tabla de s\u00edmbolos, esta nos sirve para guardar en que posici\u00f3n del activation record se encuentran los s\u00edmbolos (variables locales y par\u00e1metros) en relaci\u00f3n al frame pointer. p : Nos sirve para imprimir el c\u00f3digo generado a un archivo. Ustedes tienen que implementar el m\u00e9todo code para los nodos antes mencionados con ayuda de la clase CgenSupport.java . Function \u00b6 Function en cuesti\u00f3n de implementaci\u00f3n es lo m\u00e1s complicado del laboratorio y lo primero que tienen que hacer. Usaremos este nodo como tutorial. Consideremos el mismo ejemplo anterior: def foo ( x : int , y : int ): void { int var = 10 ; print ( var + x + y ); } El generador de c\u00f3digo para una funci\u00f3n de Viper tiene que hacer los siguientes puntos: Definir una etiqueta que represente a la funci\u00f3n. Reservar espacio en el stack para las variables locales, el registro fp y el registro ra. Crear un nuevo scope. Guardar en O la direcci\u00f3n de los formals en relaci\u00f3n al registro fp. Mandar a llamar a code de los statements dentro de la funci\u00f3n. Mandar a llamar a code de la expresi\u00f3n de return. Destruir el scope creado. Restaurar el stack, contemplando tambi\u00e9n el espacio que se reservo para los formals de parte del caller. Para definir la etiqueta que represente a la funci\u00f3n vamos a utilizar lo siguiente: CgenSupport . emitLabelDef ( CgenSupport . DEF + name , p ); Esto imprimir\u00e1 en el archivo donde estar\u00e1 el c\u00f3digo generado lo siguiente: def_foo: Luego tenemos que saber cuanto espacio necesitamos reservar para las variables locales y los dos registros fp y ra . El m\u00e9todo locals() que est\u00e1 implementado en el nodo Statements nos ayuda a determinar la cantidad de espacio que se necesita reservar para las variables locales que van a aparecer dentro del cuerpo de la funci\u00f3n y adem\u00e1s sabemos que necesitamos 2 palabras adicionales para los registros fp y ra . Sabiendo eso podemos reservar espacio y crear el pr\u00f3logo de la funci\u00f3n utilizando lo siguiente: int size = statements . locals () + 2 ; CgenSupport . emitPrologue ( size , p ); Esto imprimir\u00e1 lo siguiente: addi sp sp -12 sw fp 8(sp) sw ra 4(sp) addi fp sp 4 Noten que necesitamos 1 palabra para la variable local que aparece dentro del cuerpo de la funci\u00f3n y adem\u00e1s, 2 palabras adicionales para los registros fp y ra para un total de 3 palabras de 32 bits, es por eso que aparece el -12 (3 * 4 = 12). Tambi\u00e9n noten como se guardan los registros y como se establece el frame pointer para que apunte hacia ra . La funci\u00f3n locals() ya est\u00e1 hecha en el laboratorio, pero para el proyecto ustedes la deben implementar. Esta funci\u00f3n no es tan trivial como parece, recuerden que en un determinado tiempo hay variables vivas y variables muertas, por ejemplo: def foo (): void { int x = 10 ; while ( x > 0 ) { int y = 20 ; ... } int z = 30 ; ... } Cuando llegamos a la declaraci\u00f3n int z = 30 , la variable y estar\u00e1 muerta y el espacio que utiliz\u00f3 se puede reciclar. Para este caso la funci\u00f3n locals() tiene que devolver como resultado que se necesitan 2 palabras de 32 bits para las variables locales de la funci\u00f3n, sabiendo que el espacio que utiliz\u00f3 y se puede reutilizar para z . Esto es lo que el compilador de referencia de cool coolc y coolc-rv hacen. Ya habiendo impreso el pr\u00f3logo podemos seguir con el paso 3 y 4, podemos hacer lo siguiente: O . enterScope (); for ( int i = 0 ; i < formals . size (); i ++) { Formal formal = formals . get ( i ); O . add ( formal . name , size + i ); } Noten como vamos indicando que los formals quedan arriba de los locals con size + i , siguiendo con el ejemplo si size = 3 , entonces el par\u00e1metro x queda 3 posiciones arriba del frame pointer e y 4 posiciones arriba. Para los pasos 5 y 6 basta con llamar a code para los statements y la expresi\u00f3n de retorno: statements . code ( new Counter ( 2 ), O , p ); ret . code ( new Counter ( 2 ), O , p ); Se preguntar\u00e1n \u00bfpor qu\u00e9 el new Counter(2) ? Recuerden que el primer par\u00e1metro de la funci\u00f3n code es un contador que nos indica el siguiente espacio disponible en el \u00e1rea de variables locales en relaci\u00f3n al frame pointer. La primer variable siempre se encontrar\u00e1 2 posiciones arriba del fp porque ra est\u00e1 al mismo nivel que fp y old fp est\u00e1 una posici\u00f3n arriba. Luego hay que cerrar el scope: O . exitScope (); Y por \u00faltimo restaurar el stack, el ep\u00edlogo de la funci\u00f3n en otras palabras: CgenSupport . emitEpilogue ( size + formals . size (), p ); Esto imprimir\u00e1 lo siguiente: lw fp 8(sp) lw ra 4(sp) addi sp sp 20 ret Noten que estamos mandando size + formals.size() , ya que necesitamos restaurar tambi\u00e9n el espacio reservado por el caller que utiliz\u00f3 para meter los par\u00e1metros de la funci\u00f3n. Por eso el 20 , porque se reservaron 3 palabras en el pr\u00f3logo del callee y 2 par\u00e1metros tiene la funci\u00f3n para un total de 5 palabras de 32 bits (5 * 4 = 20). Call \u00b6 Para call ustedes tendr\u00edan que recorrer los actuals en el orden inverso, mandar a llamar a code y hacer push del resultado (que est\u00e1 en a0 ) en el stack. Luego hacer un jal hacia la funci\u00f3n que se est\u00e1 mandando a llamar utilizando: CgenSupport . emitJal ( CgenSupport . DEF + name , p ); En el nodo call hay un caso especial cuando se est\u00e1 mandando a llamar a la funci\u00f3n print/println , ya que estas aceptan imprimir enteros, booleans y strings, es necesario saber el tipo del argumento, para mandar a llamar a la funci\u00f3n correcta: def_print_int / def_println_int > para un argumento de tipo int def_print_bool / def_println_bool > para un argumento de tipo bool def_print_str / def_println_str > para un argumento de tipo str isPrint() Utilicen el m\u00e9todo isPrint() del nodo Call para saber si se est\u00e1 mandando a llamar ya sea a print o a println . Constantes \u00b6 Para las constantes simplemente es cargar al acumulador (registro a0 ) la constante utilizando los siguientes m\u00e9todos que est\u00e1n en CgenSupport.java : public static void emitLoadBool ( String dest , boolean val , PrintStream p ); public static void emitLoadString ( String dest , String val , PrintStream p ); public static void emitLoadInt ( String dest , String val , PrintStream p ); Nodos Aritm\u00e9ticos \u00b6 Para los nodos aritm\u00e9ticos basta seguir las reglas del accumulator machine vistas en clase, por ejemplo si tuvieramos lo siguiente: 2 + (3 * 2) Un accumulator machine har\u00eda lo siguiente: li a0, 2 sw a0, 0(sp) addi sp, sp, -4 li a0, 3 sw a0, 0(sp) addi sp, sp, -4 li a0, 2 lw t1, 4(sp) addi sp, sp, 4 mul a0, t1, a0 lw t1, 4(sp) addi sp, sp, 4 add a0, t1, a0 Vean los m\u00e9todos dentro de CgenSupport.java que les ayuden a implementar estos nodos, para el nodo Div hay algo adicional para manejar la divisi\u00f3n por cero, miren lo que el compilador de referencia genera. !!! info \"Label adicional Van a tener que utilizar CgenSupport.nextLabel() en Div Return \u00b6 Facilito, simplemente llamar a code de la expresi\u00f3n del return. Autograder \u00b6 Para probar su implementaci\u00f3n pueden correr lo siguiente: sudo ./gradlew build ./check Si todo est\u00e1 bien les tendr\u00eda que salir lo siguiente: Autograder +1 ( call ) +1 ( arith ) +1 ( constants ) +1 ( return ) = > You got a score of 100 out of 100 .","title":"9: Codegen 1"},{"location":"labs/lab09/#lab-9-40codegen-i41","text":"En este laboratorio van a generar c\u00f3digo en lenguaje ensamblador RISC-V para algunos nodos del lenguaje Viper que utilizar\u00f3n en el laboratorio 6 y 7. Debido a que este lenguaje no es orientado a objetos es m\u00e1s f\u00e1cil generar c\u00f3digo. Los archivos necesarios para este laboratorio los pueden encontrar en el siguiente enlace: https://classroom.github.com/a/dVwKmUVB Los archivos base tienen la misma estructura que vieron anteriormente en los laboratorios 6 y 7. Para este laboratorio el an\u00e1lisis sem\u00e1ntico ya est\u00e1 hecho, as\u00ed que no se tienen que preocupar de esta tarea, solamente se tienen que enfocar en generar c\u00f3digo implementando un Accumulator Machine . Lean bien Este lab es m\u00e1s complejo que los anteriores, por favor lean todas las instrucciones del lab, antes de empezar.","title":"Lab 9 (CodeGen I)"},{"location":"labs/lab09/#activation-record","text":"El activation record para las funciones de Viper es muy similar al que tienen que utilizar para los m\u00e9todos de COOL. Si tuvieramos la siguiente funci\u00f3n de Viper def foo ( x : int , y : int ): void { int var = 10 ; print ( var + x + y ); } El activation record ser\u00eda el siguiente:","title":"Activation Record"},{"location":"labs/lab09/#soporte","text":"Tanto en el proyecto, como en este laboratorio, van a encontrar una clase de ayuda llamada CgenSupport.java que contiene algunas definiciones que sirven para generar c\u00f3digo, revisen esta clase para hacerse una idea de lo que pueden hacer con ella. Aplicar ingenier\u00eda inversa es factible, siempre y cuando tengamos claro que est\u00e1 sucediendo. Utilizando el siguiente comando podemos compilar un archivo y ver lo que el generador de c\u00f3digo ya hecho genera, para que podamos imitar ese comportamiento. ./vipercl <archivo> Para compilar un archivo, utilizando su propio generador de c\u00f3digo pueden hacer lo siguiente. ./compile <archivo> Pueden correr un programa compilado utilizando lo siguiente. ./run <archivo>","title":"Soporte"},{"location":"labs/lab09/#generando-codigo","text":"Ustedes tienen que generar c\u00f3digo para los siguientes nodos de Viper: Function Call BoolConst IntConst StrConst Add Sub Div Mod Mul Return Cada nodo de Viper tiene un m\u00e9todo code con la siguiente firma: public void code ( Counter locals , SymbolTable O , PrintStream p ) Los par\u00e1metros tienen el siguiente significado: locals : un contador que nos ayuda a saber cual es el siguiente espacio disponible en el \u00e1rea de variables locales dentro del activation record en relaci\u00f3n al frame pointer (no se utilizar\u00e1 en este laboratorio). O : Es nuestra tabla de s\u00edmbolos, esta nos sirve para guardar en que posici\u00f3n del activation record se encuentran los s\u00edmbolos (variables locales y par\u00e1metros) en relaci\u00f3n al frame pointer. p : Nos sirve para imprimir el c\u00f3digo generado a un archivo. Ustedes tienen que implementar el m\u00e9todo code para los nodos antes mencionados con ayuda de la clase CgenSupport.java .","title":"Generando C\u00f3digo"},{"location":"labs/lab09/#function","text":"Function en cuesti\u00f3n de implementaci\u00f3n es lo m\u00e1s complicado del laboratorio y lo primero que tienen que hacer. Usaremos este nodo como tutorial. Consideremos el mismo ejemplo anterior: def foo ( x : int , y : int ): void { int var = 10 ; print ( var + x + y ); } El generador de c\u00f3digo para una funci\u00f3n de Viper tiene que hacer los siguientes puntos: Definir una etiqueta que represente a la funci\u00f3n. Reservar espacio en el stack para las variables locales, el registro fp y el registro ra. Crear un nuevo scope. Guardar en O la direcci\u00f3n de los formals en relaci\u00f3n al registro fp. Mandar a llamar a code de los statements dentro de la funci\u00f3n. Mandar a llamar a code de la expresi\u00f3n de return. Destruir el scope creado. Restaurar el stack, contemplando tambi\u00e9n el espacio que se reservo para los formals de parte del caller. Para definir la etiqueta que represente a la funci\u00f3n vamos a utilizar lo siguiente: CgenSupport . emitLabelDef ( CgenSupport . DEF + name , p ); Esto imprimir\u00e1 en el archivo donde estar\u00e1 el c\u00f3digo generado lo siguiente: def_foo: Luego tenemos que saber cuanto espacio necesitamos reservar para las variables locales y los dos registros fp y ra . El m\u00e9todo locals() que est\u00e1 implementado en el nodo Statements nos ayuda a determinar la cantidad de espacio que se necesita reservar para las variables locales que van a aparecer dentro del cuerpo de la funci\u00f3n y adem\u00e1s sabemos que necesitamos 2 palabras adicionales para los registros fp y ra . Sabiendo eso podemos reservar espacio y crear el pr\u00f3logo de la funci\u00f3n utilizando lo siguiente: int size = statements . locals () + 2 ; CgenSupport . emitPrologue ( size , p ); Esto imprimir\u00e1 lo siguiente: addi sp sp -12 sw fp 8(sp) sw ra 4(sp) addi fp sp 4 Noten que necesitamos 1 palabra para la variable local que aparece dentro del cuerpo de la funci\u00f3n y adem\u00e1s, 2 palabras adicionales para los registros fp y ra para un total de 3 palabras de 32 bits, es por eso que aparece el -12 (3 * 4 = 12). Tambi\u00e9n noten como se guardan los registros y como se establece el frame pointer para que apunte hacia ra . La funci\u00f3n locals() ya est\u00e1 hecha en el laboratorio, pero para el proyecto ustedes la deben implementar. Esta funci\u00f3n no es tan trivial como parece, recuerden que en un determinado tiempo hay variables vivas y variables muertas, por ejemplo: def foo (): void { int x = 10 ; while ( x > 0 ) { int y = 20 ; ... } int z = 30 ; ... } Cuando llegamos a la declaraci\u00f3n int z = 30 , la variable y estar\u00e1 muerta y el espacio que utiliz\u00f3 se puede reciclar. Para este caso la funci\u00f3n locals() tiene que devolver como resultado que se necesitan 2 palabras de 32 bits para las variables locales de la funci\u00f3n, sabiendo que el espacio que utiliz\u00f3 y se puede reutilizar para z . Esto es lo que el compilador de referencia de cool coolc y coolc-rv hacen. Ya habiendo impreso el pr\u00f3logo podemos seguir con el paso 3 y 4, podemos hacer lo siguiente: O . enterScope (); for ( int i = 0 ; i < formals . size (); i ++) { Formal formal = formals . get ( i ); O . add ( formal . name , size + i ); } Noten como vamos indicando que los formals quedan arriba de los locals con size + i , siguiendo con el ejemplo si size = 3 , entonces el par\u00e1metro x queda 3 posiciones arriba del frame pointer e y 4 posiciones arriba. Para los pasos 5 y 6 basta con llamar a code para los statements y la expresi\u00f3n de retorno: statements . code ( new Counter ( 2 ), O , p ); ret . code ( new Counter ( 2 ), O , p ); Se preguntar\u00e1n \u00bfpor qu\u00e9 el new Counter(2) ? Recuerden que el primer par\u00e1metro de la funci\u00f3n code es un contador que nos indica el siguiente espacio disponible en el \u00e1rea de variables locales en relaci\u00f3n al frame pointer. La primer variable siempre se encontrar\u00e1 2 posiciones arriba del fp porque ra est\u00e1 al mismo nivel que fp y old fp est\u00e1 una posici\u00f3n arriba. Luego hay que cerrar el scope: O . exitScope (); Y por \u00faltimo restaurar el stack, el ep\u00edlogo de la funci\u00f3n en otras palabras: CgenSupport . emitEpilogue ( size + formals . size (), p ); Esto imprimir\u00e1 lo siguiente: lw fp 8(sp) lw ra 4(sp) addi sp sp 20 ret Noten que estamos mandando size + formals.size() , ya que necesitamos restaurar tambi\u00e9n el espacio reservado por el caller que utiliz\u00f3 para meter los par\u00e1metros de la funci\u00f3n. Por eso el 20 , porque se reservaron 3 palabras en el pr\u00f3logo del callee y 2 par\u00e1metros tiene la funci\u00f3n para un total de 5 palabras de 32 bits (5 * 4 = 20).","title":"Function"},{"location":"labs/lab09/#call","text":"Para call ustedes tendr\u00edan que recorrer los actuals en el orden inverso, mandar a llamar a code y hacer push del resultado (que est\u00e1 en a0 ) en el stack. Luego hacer un jal hacia la funci\u00f3n que se est\u00e1 mandando a llamar utilizando: CgenSupport . emitJal ( CgenSupport . DEF + name , p ); En el nodo call hay un caso especial cuando se est\u00e1 mandando a llamar a la funci\u00f3n print/println , ya que estas aceptan imprimir enteros, booleans y strings, es necesario saber el tipo del argumento, para mandar a llamar a la funci\u00f3n correcta: def_print_int / def_println_int > para un argumento de tipo int def_print_bool / def_println_bool > para un argumento de tipo bool def_print_str / def_println_str > para un argumento de tipo str isPrint() Utilicen el m\u00e9todo isPrint() del nodo Call para saber si se est\u00e1 mandando a llamar ya sea a print o a println .","title":"Call"},{"location":"labs/lab09/#constantes","text":"Para las constantes simplemente es cargar al acumulador (registro a0 ) la constante utilizando los siguientes m\u00e9todos que est\u00e1n en CgenSupport.java : public static void emitLoadBool ( String dest , boolean val , PrintStream p ); public static void emitLoadString ( String dest , String val , PrintStream p ); public static void emitLoadInt ( String dest , String val , PrintStream p );","title":"Constantes"},{"location":"labs/lab09/#nodos-aritmeticos","text":"Para los nodos aritm\u00e9ticos basta seguir las reglas del accumulator machine vistas en clase, por ejemplo si tuvieramos lo siguiente: 2 + (3 * 2) Un accumulator machine har\u00eda lo siguiente: li a0, 2 sw a0, 0(sp) addi sp, sp, -4 li a0, 3 sw a0, 0(sp) addi sp, sp, -4 li a0, 2 lw t1, 4(sp) addi sp, sp, 4 mul a0, t1, a0 lw t1, 4(sp) addi sp, sp, 4 add a0, t1, a0 Vean los m\u00e9todos dentro de CgenSupport.java que les ayuden a implementar estos nodos, para el nodo Div hay algo adicional para manejar la divisi\u00f3n por cero, miren lo que el compilador de referencia genera. !!! info \"Label adicional Van a tener que utilizar CgenSupport.nextLabel() en Div","title":"Nodos Aritm\u00e9ticos"},{"location":"labs/lab09/#return","text":"Facilito, simplemente llamar a code de la expresi\u00f3n del return.","title":"Return"},{"location":"labs/lab09/#autograder","text":"Para probar su implementaci\u00f3n pueden correr lo siguiente: sudo ./gradlew build ./check Si todo est\u00e1 bien les tendr\u00eda que salir lo siguiente: Autograder +1 ( call ) +1 ( arith ) +1 ( constants ) +1 ( return ) = > You got a score of 100 out of 100 .","title":"Autograder"},{"location":"labs/lab10/","text":"Lab 10 (CodeGen II) \u00b6 Para este laboratorio van a completar la generaci\u00f3n de c\u00f3digo para el lenguaje Viper Los archivos necesarios para este laboratorio los pueden encontrar en el siguiente enlace: https://classroom.github.com/a/hI0ofQwY Lean bien Este lab es m\u00e1s complejo que los anteriores, por favor lean todas las instrucciones del lab, antes de empezar. Recordatorio \u00b6 Por favor revisen el siguiente enlace para recordarse c\u00f3mo est\u00e1 estructurado el Activation Record en Viper: Lab 9: Codegen 1 Variables Locales \u00b6 Si no se recuerden de la firma del m\u00e9todo code aqu\u00ed est\u00e1 nuevamente: public void code ( Counter locals , SymbolTable O , PrintStream p ) Los par\u00e1metros tienen el siguiente significado: locals : un contador que nos ayuda a saber cual es el siguiente espacio disponible en el \u00e1rea de variables locales dentro del activation record en relaci\u00f3n al frame pointer. O : Es nuestra tabla de s\u00edmbolos, esta nos sirve para guardar en que posici\u00f3n del activation record se encuentran los s\u00edmbolos (variables locales y par\u00e1metros) en relaci\u00f3n al frame pointer. p : Nos sirve para imprimir el c\u00f3digo generado a un archivo.Activation Record Cuando ustedes implementaron el nodo Function se dieron cuenta que fue necesario llamar al m\u00e9todo locals() para preparar parte del pr\u00f3logo de la funci\u00f3n (reservar espacio). Esta funci\u00f3n solo tiene una tarea en espec\u00edfico y es decir la cantidad de espacio necesario a reservar dentro del Activation Record para todas las variables locales (sin contar par\u00e1metros formales). Esta funci\u00f3n lo que hace es visitar cada nodo dentro de los statements de una funci\u00f3n (recursivamente) y verificar si son una instancia del nodo Declaration e ir incrementando la cantidad de espacio con +1 cada vez que esto suceda. Si ustedes revisan la implementaci\u00f3n de este m\u00e9todo realmente hace m\u00e1s cosas, por ejemplo en el caso de un If : if ( true ) { int x = 10 ; int y = 20 ; } else { int z = 30 ; } locals() devolver\u00eda 2 en vez de 1, porque en tiempo de compilaci\u00f3n no se sabe si se va a tomar la consecuencia o la alternativa (a menos que se hiciera una optimizaci\u00f3n que por el momento est\u00e1 fuera del objetivo de este laboratorio), por lo que es necesario devolver el m\u00e1ximo entre los dos bloques de statements del If . Una implementaci\u00f3n un poco m\u00e1s ineficiente en t\u00e9rminos de memoria ser\u00eda que locals() devolviera 3 para x , y y z , esto es ineficiente porque el espacio que se reserva para x y y se puede reutilizar para z porque el scope de la consecuencia no es el mismo ni se comparte con el de la alternativa. Ustedes son libres de implementar esto en su proyecto como ustedes crean que les permita terminarlo al 100%. Otra cosa importante que deben tener claro es que el \u00fanico nodo que puede aumentar la cantidad de espacio a reservar en Viper es Declaration y los lugares donde puede aparecer este nodo es dentro de una funci\u00f3n, dentro de los bloques de un If , y dentro del bloque de un While . En COOL ustedes van a tener que considerar a Let y a Typecase como los responsables de incrementar la cantidad de espacio. Bien, ahora que ya est\u00e1 un poco m\u00e1s claro como funciona locals() es hora de hablar un poco de como utilizar ese espacio (lo que necesitan realmente para este laboratorio). Como el espacio se reserva en el activation record de la funci\u00f3n, para referenciar una posici\u00f3n de ese espacio de manera f\u00e1cil es utilizando el frame pointer (el registro fp ). Volvamos al ejemplo del laboratorio pasado: def foo ( x : int , y : int ): void { int var = 10 ; print ( var + x + y ); } Si se quisiera acceder al valor de la variable var bastar\u00eda con hacer lo siguiente en el ensamblador: lw a0, 8(fp) Para su proyecto Como COOL es orientado a objetos y pueden haber atributos en cada clase, cuando se hace referencia a un identificador, este podr\u00eda ser un atributo o variable local por lo que para hacer referencia a su espacio de memoria podr\u00eda ser utilizando el frame pointer o el registro s0 que guarda el self object. Soporte \u00b6 Se les provee como en el laboratorio pasado un compilador completo de Viper: ./vipercl <archivo .vp> pueden probar esto para tener una referencia de como es que se tiene que generar c\u00f3digo para los diferentes nodos de este laboratorio (pueden hacer lo mismo en el proyecto con coolc-rv ). Para correr un archivo compilado, pueden utilizar: ./run <archivo .s> Adicionalmente pueden utilizar los m\u00e9todos y variables est\u00e1ticas de la clase CgenSupport para ayudarse a generar c\u00f3digo. Generando C\u00f3digo \u00b6 Los nodos restantes que ustedes tienen que completar son los siguientes: Assign Declaration Equal LessEqual LessThan Not Id If While Para que tengan una idea de que tanto tienen que realizar, aqu\u00ed van unas estad\u00edsticas: src/main/java/viper/tree/Assign.java | 4 +++- src/main/java/viper/tree/Declaration.java | 6 +++++- src/main/java/viper/tree/Equal.java | 11 ++++++++++- src/main/java/viper/tree/Id.java | 3 ++- src/main/java/viper/tree/If.java | 15 ++++++++++++++- src/main/java/viper/tree/LessEqual.java | 11 ++++++++++- src/main/java/viper/tree/LessThan.java | 11 ++++++++++- src/main/java/viper/tree/Not.java | 8 +++++++- src/main/java/viper/tree/While.java | 12 +++++++++++- 9 files changed, 72 insertions ( + ) , 9 deletions ( - ) Assign \u00b6 La generaci\u00f3n de c\u00f3digo para Assign es de pocos pasos. Primero se tiene que mandar recursivamente a code de la expresi\u00f3n del nodo y cuando regrese el resultado estar\u00e1 en a0 , luego determinar a que distancia del frame pointer esta guardada esa variable utilizando a O y por \u00faltimo guardar el resultado en ese espacio. Reutilizando la tabla O Utilicen O.lookup(name) para determinar esa distancia. \u00bfPor qu\u00e9 lookup y no probe? Declaration \u00b6 En Declaration casi se tiene que hacer lo mismo que en Assign , la diferencia es que en Declaration se est\u00e1 creando una variable y se le est\u00e1 asignando un valor inicial y en Assign la variable ya fue creada y solo se le est\u00e1 asignado un nuevo valor. Tienen que llamar a code de init recursivamente, el resultado cuando regrese estar\u00e1 en a0 . Tienen que reservar el siguiente espacio disponible en el \u00e1rea de variables locales para la variable que est\u00e1 siendo creada y agregar esta informaci\u00f3n en la tabla O . Luego guardar a0 en ese espacio. Por \u00faltimo como este nodo no es una expresi\u00f3n, tenemos que cargar en a0 el valor de void que es simplemente un 0. Usando el contador locals Utilicen locals.inc() para reservar el siguiente espacio y O.add(name, offset) para guardar esa informaci\u00f3n en la tabla de s\u00edmbolos. Cargando en a0 Para cargar en a0 void pueden hacer lo siguiente: CgenSupport . emitLoadImm ( CgenSupport . A0 , 0 , p ); Comparaciones \u00b6 Para LessEqual , LessThan e Equal , la generaci\u00f3n de c\u00f3digo es igual en Viper. Primero tienen que crear una nueva etiqueta, llamar recursivamente a code del primer operando, hacer push de a0 en el stack, luego llamar recursivamente a code del segundo operando, mover el resultado al registro t1 hacer pop del stack hacia el registro t2 , cargar en a0 el boolean true efectuar la comparaci\u00f3n correspondiente (<, <=, ==) utilizando los registros t1 y t2 , cargar el boolean false en caso de que la comparaci\u00f3n no se cumpla y por \u00faltimo definir la etiqueta que crearon. Etiquetas Para crear una nueva etiqueta pueden utilizar el m\u00e9todo nextLabel() de CgenSupport . Para definir la etiqueta pueden utilizar emitLabelDef(label, p) tambi\u00e9n de CgenSupport . Not \u00b6 El Not es similar a las comparaciones, lo \u00fanico es que aqu\u00ed solo mandamos a llamar a code del \u00fanico operando que hay. Luego se tienen que realizar los mismos pasos que se mencionaron anterior mente. Branch on equal zero Van a encontrar \u00fatil el m\u00e9todo CgenSupport.emitBeqz() Id \u00b6 Como sabemos la distancia desde el frame pointer en la que el Id fue guardado podemos utilizar la tabla O para obtener esa distancia y cargar en el registro a0 el valor de ese espacio en memoria. While \u00b6 Primero se tienen que crear dos etiquetas, una para iterar y otra para salir del ciclo, definir una de las primeras etiquetas (la de iterar), hacer code de la condici\u00f3n, comparar a0 con 0 para saltar a la etiqueta para salir (recurden 0 es falso y 1 verdadero), crear un nuevo scope para el cuerpo del ciclo, hacer code del body (para esto tienen que crear una copia del contador de variables locales), salir del scope que se acaba de crear, saltar a la etiqueta que nos sirve para iterar, definir la etiqueta para salir, por \u00faltimo cargar void al registro a0 . Copiando el contador locals Utilicen el m\u00e9todo locals.copy() para crear una copia del contador de variables locales. If \u00b6 El If es similar al While , primero se crean dos etiquetas, una para la alternativa y otra para la salir de la consecuencia, luego se manda a llamar a code del predicado del nodo, luego se tiene que comparar a0 con 0 para saltar a la alternativa, luego se crear un scope y se manda a llamar a code de then (se tiene que crear una copia de locals como se hizo en el While ), salir del scope que se acaba de crear, saltar a la etiqueta de salir de la consecuencia, definir la etiqueta de la alternativa, crear un nuevo scope (aqu\u00ed tambi\u00e9n se tiene que copiar locals), salir del scope que se acaba de crear, definir la etiqueta de salir y por \u00faltimo cargar en a0 el valor void . Listo han terminado de generar c\u00f3digo para un lenguaje de bastante modesto, pero que puede hacer cosas interesantes todav\u00eda, por ejemplo: def factorial ( n : int ): int { int result = 0 ; if ( n < 2 ) { result = 1 ; } else { result = n * factorial ( n - 1 ); } return result ; } def main (): int { int n = input ( 'enter a number: ' ); println (); print ( 'fact(' ); print ( n ); print ( ') = ' ); print ( factorial ( n )); return 0 ; } Pruebas \u00b6 Para probar lo que genera su implementaci\u00f3n pueden utilizar lo siguiente: sudo ./gradlew build # para compilar su laboratorio sudo ./gradlew clean assemble # no deberia necesitarlo, pero si hay algun problema que no se quita ./compile <archivo.vp> # compilar usando su laboratorio ./vipercl <archivo.vp> # usar el compilador de prueba En la carpeta examples/ hay un par de ejemplos. Autograder \u00b6 Despu\u00e9s de hacer build, puede obtener su nota con este comando: ./check Si todo est\u00e1 bien, tendr\u00edan que obtener la siguiente salida: Autograder +4.55 ( while2 ) +4.55 ( leq ) +4.55 ( lt ) +4.55 ( eq ) +4.55 ( call ) +4.55 ( arith ) +4.55 ( fibo ) +4.55 ( declaration2 ) +4.55 ( factorial ) +4.55 ( declaration3 ) +4.55 ( if2 ) +4.55 ( not ) +4.55 ( assign2 ) +4.55 ( constants ) +4.55 ( return ) +4.55 ( lt2 ) +4.55 ( while ) +4.55 ( if1 ) +4.55 ( declaration ) +4.55 ( assign ) +4.55 ( leq2 ) +4.55 ( not2 ) = > You got a score of 100 out of 100 .","title":"10: Codegen 2"},{"location":"labs/lab10/#lab-10-40codegen-ii41","text":"Para este laboratorio van a completar la generaci\u00f3n de c\u00f3digo para el lenguaje Viper Los archivos necesarios para este laboratorio los pueden encontrar en el siguiente enlace: https://classroom.github.com/a/hI0ofQwY Lean bien Este lab es m\u00e1s complejo que los anteriores, por favor lean todas las instrucciones del lab, antes de empezar.","title":"Lab 10 (CodeGen II)"},{"location":"labs/lab10/#recordatorio","text":"Por favor revisen el siguiente enlace para recordarse c\u00f3mo est\u00e1 estructurado el Activation Record en Viper: Lab 9: Codegen 1","title":"Recordatorio"},{"location":"labs/lab10/#variables-locales","text":"Si no se recuerden de la firma del m\u00e9todo code aqu\u00ed est\u00e1 nuevamente: public void code ( Counter locals , SymbolTable O , PrintStream p ) Los par\u00e1metros tienen el siguiente significado: locals : un contador que nos ayuda a saber cual es el siguiente espacio disponible en el \u00e1rea de variables locales dentro del activation record en relaci\u00f3n al frame pointer. O : Es nuestra tabla de s\u00edmbolos, esta nos sirve para guardar en que posici\u00f3n del activation record se encuentran los s\u00edmbolos (variables locales y par\u00e1metros) en relaci\u00f3n al frame pointer. p : Nos sirve para imprimir el c\u00f3digo generado a un archivo.Activation Record Cuando ustedes implementaron el nodo Function se dieron cuenta que fue necesario llamar al m\u00e9todo locals() para preparar parte del pr\u00f3logo de la funci\u00f3n (reservar espacio). Esta funci\u00f3n solo tiene una tarea en espec\u00edfico y es decir la cantidad de espacio necesario a reservar dentro del Activation Record para todas las variables locales (sin contar par\u00e1metros formales). Esta funci\u00f3n lo que hace es visitar cada nodo dentro de los statements de una funci\u00f3n (recursivamente) y verificar si son una instancia del nodo Declaration e ir incrementando la cantidad de espacio con +1 cada vez que esto suceda. Si ustedes revisan la implementaci\u00f3n de este m\u00e9todo realmente hace m\u00e1s cosas, por ejemplo en el caso de un If : if ( true ) { int x = 10 ; int y = 20 ; } else { int z = 30 ; } locals() devolver\u00eda 2 en vez de 1, porque en tiempo de compilaci\u00f3n no se sabe si se va a tomar la consecuencia o la alternativa (a menos que se hiciera una optimizaci\u00f3n que por el momento est\u00e1 fuera del objetivo de este laboratorio), por lo que es necesario devolver el m\u00e1ximo entre los dos bloques de statements del If . Una implementaci\u00f3n un poco m\u00e1s ineficiente en t\u00e9rminos de memoria ser\u00eda que locals() devolviera 3 para x , y y z , esto es ineficiente porque el espacio que se reserva para x y y se puede reutilizar para z porque el scope de la consecuencia no es el mismo ni se comparte con el de la alternativa. Ustedes son libres de implementar esto en su proyecto como ustedes crean que les permita terminarlo al 100%. Otra cosa importante que deben tener claro es que el \u00fanico nodo que puede aumentar la cantidad de espacio a reservar en Viper es Declaration y los lugares donde puede aparecer este nodo es dentro de una funci\u00f3n, dentro de los bloques de un If , y dentro del bloque de un While . En COOL ustedes van a tener que considerar a Let y a Typecase como los responsables de incrementar la cantidad de espacio. Bien, ahora que ya est\u00e1 un poco m\u00e1s claro como funciona locals() es hora de hablar un poco de como utilizar ese espacio (lo que necesitan realmente para este laboratorio). Como el espacio se reserva en el activation record de la funci\u00f3n, para referenciar una posici\u00f3n de ese espacio de manera f\u00e1cil es utilizando el frame pointer (el registro fp ). Volvamos al ejemplo del laboratorio pasado: def foo ( x : int , y : int ): void { int var = 10 ; print ( var + x + y ); } Si se quisiera acceder al valor de la variable var bastar\u00eda con hacer lo siguiente en el ensamblador: lw a0, 8(fp) Para su proyecto Como COOL es orientado a objetos y pueden haber atributos en cada clase, cuando se hace referencia a un identificador, este podr\u00eda ser un atributo o variable local por lo que para hacer referencia a su espacio de memoria podr\u00eda ser utilizando el frame pointer o el registro s0 que guarda el self object.","title":"Variables Locales"},{"location":"labs/lab10/#soporte","text":"Se les provee como en el laboratorio pasado un compilador completo de Viper: ./vipercl <archivo .vp> pueden probar esto para tener una referencia de como es que se tiene que generar c\u00f3digo para los diferentes nodos de este laboratorio (pueden hacer lo mismo en el proyecto con coolc-rv ). Para correr un archivo compilado, pueden utilizar: ./run <archivo .s> Adicionalmente pueden utilizar los m\u00e9todos y variables est\u00e1ticas de la clase CgenSupport para ayudarse a generar c\u00f3digo.","title":"Soporte"},{"location":"labs/lab10/#generando-codigo","text":"Los nodos restantes que ustedes tienen que completar son los siguientes: Assign Declaration Equal LessEqual LessThan Not Id If While Para que tengan una idea de que tanto tienen que realizar, aqu\u00ed van unas estad\u00edsticas: src/main/java/viper/tree/Assign.java | 4 +++- src/main/java/viper/tree/Declaration.java | 6 +++++- src/main/java/viper/tree/Equal.java | 11 ++++++++++- src/main/java/viper/tree/Id.java | 3 ++- src/main/java/viper/tree/If.java | 15 ++++++++++++++- src/main/java/viper/tree/LessEqual.java | 11 ++++++++++- src/main/java/viper/tree/LessThan.java | 11 ++++++++++- src/main/java/viper/tree/Not.java | 8 +++++++- src/main/java/viper/tree/While.java | 12 +++++++++++- 9 files changed, 72 insertions ( + ) , 9 deletions ( - )","title":"Generando C\u00f3digo"},{"location":"labs/lab10/#assign","text":"La generaci\u00f3n de c\u00f3digo para Assign es de pocos pasos. Primero se tiene que mandar recursivamente a code de la expresi\u00f3n del nodo y cuando regrese el resultado estar\u00e1 en a0 , luego determinar a que distancia del frame pointer esta guardada esa variable utilizando a O y por \u00faltimo guardar el resultado en ese espacio. Reutilizando la tabla O Utilicen O.lookup(name) para determinar esa distancia. \u00bfPor qu\u00e9 lookup y no probe?","title":"Assign"},{"location":"labs/lab10/#declaration","text":"En Declaration casi se tiene que hacer lo mismo que en Assign , la diferencia es que en Declaration se est\u00e1 creando una variable y se le est\u00e1 asignando un valor inicial y en Assign la variable ya fue creada y solo se le est\u00e1 asignado un nuevo valor. Tienen que llamar a code de init recursivamente, el resultado cuando regrese estar\u00e1 en a0 . Tienen que reservar el siguiente espacio disponible en el \u00e1rea de variables locales para la variable que est\u00e1 siendo creada y agregar esta informaci\u00f3n en la tabla O . Luego guardar a0 en ese espacio. Por \u00faltimo como este nodo no es una expresi\u00f3n, tenemos que cargar en a0 el valor de void que es simplemente un 0. Usando el contador locals Utilicen locals.inc() para reservar el siguiente espacio y O.add(name, offset) para guardar esa informaci\u00f3n en la tabla de s\u00edmbolos. Cargando en a0 Para cargar en a0 void pueden hacer lo siguiente: CgenSupport . emitLoadImm ( CgenSupport . A0 , 0 , p );","title":"Declaration"},{"location":"labs/lab10/#comparaciones","text":"Para LessEqual , LessThan e Equal , la generaci\u00f3n de c\u00f3digo es igual en Viper. Primero tienen que crear una nueva etiqueta, llamar recursivamente a code del primer operando, hacer push de a0 en el stack, luego llamar recursivamente a code del segundo operando, mover el resultado al registro t1 hacer pop del stack hacia el registro t2 , cargar en a0 el boolean true efectuar la comparaci\u00f3n correspondiente (<, <=, ==) utilizando los registros t1 y t2 , cargar el boolean false en caso de que la comparaci\u00f3n no se cumpla y por \u00faltimo definir la etiqueta que crearon. Etiquetas Para crear una nueva etiqueta pueden utilizar el m\u00e9todo nextLabel() de CgenSupport . Para definir la etiqueta pueden utilizar emitLabelDef(label, p) tambi\u00e9n de CgenSupport .","title":"Comparaciones"},{"location":"labs/lab10/#not","text":"El Not es similar a las comparaciones, lo \u00fanico es que aqu\u00ed solo mandamos a llamar a code del \u00fanico operando que hay. Luego se tienen que realizar los mismos pasos que se mencionaron anterior mente. Branch on equal zero Van a encontrar \u00fatil el m\u00e9todo CgenSupport.emitBeqz()","title":"Not"},{"location":"labs/lab10/#id","text":"Como sabemos la distancia desde el frame pointer en la que el Id fue guardado podemos utilizar la tabla O para obtener esa distancia y cargar en el registro a0 el valor de ese espacio en memoria.","title":"Id"},{"location":"labs/lab10/#while","text":"Primero se tienen que crear dos etiquetas, una para iterar y otra para salir del ciclo, definir una de las primeras etiquetas (la de iterar), hacer code de la condici\u00f3n, comparar a0 con 0 para saltar a la etiqueta para salir (recurden 0 es falso y 1 verdadero), crear un nuevo scope para el cuerpo del ciclo, hacer code del body (para esto tienen que crear una copia del contador de variables locales), salir del scope que se acaba de crear, saltar a la etiqueta que nos sirve para iterar, definir la etiqueta para salir, por \u00faltimo cargar void al registro a0 . Copiando el contador locals Utilicen el m\u00e9todo locals.copy() para crear una copia del contador de variables locales.","title":"While"},{"location":"labs/lab10/#if","text":"El If es similar al While , primero se crean dos etiquetas, una para la alternativa y otra para la salir de la consecuencia, luego se manda a llamar a code del predicado del nodo, luego se tiene que comparar a0 con 0 para saltar a la alternativa, luego se crear un scope y se manda a llamar a code de then (se tiene que crear una copia de locals como se hizo en el While ), salir del scope que se acaba de crear, saltar a la etiqueta de salir de la consecuencia, definir la etiqueta de la alternativa, crear un nuevo scope (aqu\u00ed tambi\u00e9n se tiene que copiar locals), salir del scope que se acaba de crear, definir la etiqueta de salir y por \u00faltimo cargar en a0 el valor void . Listo han terminado de generar c\u00f3digo para un lenguaje de bastante modesto, pero que puede hacer cosas interesantes todav\u00eda, por ejemplo: def factorial ( n : int ): int { int result = 0 ; if ( n < 2 ) { result = 1 ; } else { result = n * factorial ( n - 1 ); } return result ; } def main (): int { int n = input ( 'enter a number: ' ); println (); print ( 'fact(' ); print ( n ); print ( ') = ' ); print ( factorial ( n )); return 0 ; }","title":"If"},{"location":"labs/lab10/#pruebas","text":"Para probar lo que genera su implementaci\u00f3n pueden utilizar lo siguiente: sudo ./gradlew build # para compilar su laboratorio sudo ./gradlew clean assemble # no deberia necesitarlo, pero si hay algun problema que no se quita ./compile <archivo.vp> # compilar usando su laboratorio ./vipercl <archivo.vp> # usar el compilador de prueba En la carpeta examples/ hay un par de ejemplos.","title":"Pruebas"},{"location":"labs/lab10/#autograder","text":"Despu\u00e9s de hacer build, puede obtener su nota con este comando: ./check Si todo est\u00e1 bien, tendr\u00edan que obtener la siguiente salida: Autograder +4.55 ( while2 ) +4.55 ( leq ) +4.55 ( lt ) +4.55 ( eq ) +4.55 ( call ) +4.55 ( arith ) +4.55 ( fibo ) +4.55 ( declaration2 ) +4.55 ( factorial ) +4.55 ( declaration3 ) +4.55 ( if2 ) +4.55 ( not ) +4.55 ( assign2 ) +4.55 ( constants ) +4.55 ( return ) +4.55 ( lt2 ) +4.55 ( while ) +4.55 ( if1 ) +4.55 ( declaration ) +4.55 ( assign ) +4.55 ( leq2 ) +4.55 ( not2 ) = > You got a score of 100 out of 100 .","title":"Autograder"},{"location":"labs/lab11/","text":"Lab 11 (Optimizaciones) \u00b6 Introducci\u00f3n \u00b6 El objetivo de este laboratorio es preparar el AST para la generaci\u00f3n de c\u00f3digo, aplicandole la optimizaci\u00f3n de Constant Folding . Antes de empezar, obtener los archivos desde Github Classroom: https://classroom.github.com/a/GJXSN7iR Descripci\u00f3n \u00b6 En lugar de generar c\u00f3digo de forma directa, realizaremos una de las optimizaciones mas simples: aplicaremos Constant Folding a la grm\u00e1tica siguiente, la cual solo tiene definiciones de funciones, operaciones matem\u00e1ticas y condiciones. En los archivos que descargaron, se les proporciona el codigo base del lexer , parser y AST para que ustedes puedan agregar el c\u00f3digo necesario para implementar las optimizaciones. Esta es la gramatica: P -> D P | D D -> def id(ARGS) = E; ARGS -> id, ARGS | id | lambda E -> int | id | if E = E then E else E | E + E | E - E | id(E,...,E) Constant Folding \u00b6 Para poder realizar esta fase, ustedes deben recorrer el AST de forma similar a la fase de semant, y la de cgen. El archivo que deben modificar es cool-tree.java , en la clase Main . All\u00ed deben implementar el m\u00e9todo llamado optimize() , el cual es su punto de inicio. Adem\u00e1s de esto son libres de modificar cualquier otra clase que deseen. Hint: otra clase que les puede ser \u00fatil es TreeNode.java . Una vez implementada la funci\u00f3n, si tienen el siguiente fragmento de c\u00f3digo: def foo() = 2 + 3 su programa debera optimizarlo, operando la suma y luego escribiendo una unica constante, de la siguente manera: def foo() = 5 Tomen en cuenta que para las llamadas a funciones tambien pueden realizar optimizaciones: foo(2*x,3*3) lo cual deberian cambiarlo a: foo(2*x,9) El output de su c\u00f3digo debe ser el AST optimizado por lo que las operaciones matem\u00e1ticas entre constantes deben aparecer como una sola constante (usted no debe preocuparse por desplegar el AST , esto ya lo hace el c\u00f3digo que se le proporciona, usted solo debe modificar la estructura del AST ). 4. Autograder \u00b6 Para comprobar que su c\u00f3digo funciona correctamente, pueden escribir make check : make check echo '#!/bin/sh' >> lab11 echo 'java -classpath /usr/class/cs143/cool/lib:.:/usr/java/lib/rt.jar:`dirname $0` Lab11 $*' >> lab11 chmod 755 lab11 python grading.py ##################### Autograder ####################### +0 (test3.test) +0 (test2.test) +0 (test5.test) +0 (test4.test) +0 (test1.test) +------------------------------------------------------+ | Score: 0/5| +------------------------------------------------------+ Si desea probar \u00fanicamente un archivo, encuentra varios programas en la carpeta grading . Luego de hacer make , ejecute lo siguiente: ./lab11 grading/archivoDePrueba.test","title":"11: Optimizaciones"},{"location":"labs/lab11/#lab-11-40optimizaciones41","text":"","title":"Lab 11 (Optimizaciones)"},{"location":"labs/lab11/#introduccion","text":"El objetivo de este laboratorio es preparar el AST para la generaci\u00f3n de c\u00f3digo, aplicandole la optimizaci\u00f3n de Constant Folding . Antes de empezar, obtener los archivos desde Github Classroom: https://classroom.github.com/a/GJXSN7iR","title":"Introducci\u00f3n"},{"location":"labs/lab11/#descripcion","text":"En lugar de generar c\u00f3digo de forma directa, realizaremos una de las optimizaciones mas simples: aplicaremos Constant Folding a la grm\u00e1tica siguiente, la cual solo tiene definiciones de funciones, operaciones matem\u00e1ticas y condiciones. En los archivos que descargaron, se les proporciona el codigo base del lexer , parser y AST para que ustedes puedan agregar el c\u00f3digo necesario para implementar las optimizaciones. Esta es la gramatica: P -> D P | D D -> def id(ARGS) = E; ARGS -> id, ARGS | id | lambda E -> int | id | if E = E then E else E | E + E | E - E | id(E,...,E)","title":"Descripci\u00f3n"},{"location":"labs/lab11/#constant-folding","text":"Para poder realizar esta fase, ustedes deben recorrer el AST de forma similar a la fase de semant, y la de cgen. El archivo que deben modificar es cool-tree.java , en la clase Main . All\u00ed deben implementar el m\u00e9todo llamado optimize() , el cual es su punto de inicio. Adem\u00e1s de esto son libres de modificar cualquier otra clase que deseen. Hint: otra clase que les puede ser \u00fatil es TreeNode.java . Una vez implementada la funci\u00f3n, si tienen el siguiente fragmento de c\u00f3digo: def foo() = 2 + 3 su programa debera optimizarlo, operando la suma y luego escribiendo una unica constante, de la siguente manera: def foo() = 5 Tomen en cuenta que para las llamadas a funciones tambien pueden realizar optimizaciones: foo(2*x,3*3) lo cual deberian cambiarlo a: foo(2*x,9) El output de su c\u00f3digo debe ser el AST optimizado por lo que las operaciones matem\u00e1ticas entre constantes deben aparecer como una sola constante (usted no debe preocuparse por desplegar el AST , esto ya lo hace el c\u00f3digo que se le proporciona, usted solo debe modificar la estructura del AST ).","title":"Constant Folding"},{"location":"labs/lab11/#4-autograder","text":"Para comprobar que su c\u00f3digo funciona correctamente, pueden escribir make check : make check echo '#!/bin/sh' >> lab11 echo 'java -classpath /usr/class/cs143/cool/lib:.:/usr/java/lib/rt.jar:`dirname $0` Lab11 $*' >> lab11 chmod 755 lab11 python grading.py ##################### Autograder ####################### +0 (test3.test) +0 (test2.test) +0 (test5.test) +0 (test4.test) +0 (test1.test) +------------------------------------------------------+ | Score: 0/5| +------------------------------------------------------+ Si desea probar \u00fanicamente un archivo, encuentra varios programas en la carpeta grading . Luego de hacer make , ejecute lo siguiente: ./lab11 grading/archivoDePrueba.test","title":"4. Autograder"},{"location":"projs/proj00/","text":"Instalaci\u00f3n de material \u00b6 Sus laboratorios y proyectos de CC4 se trabajar\u00e1n en Ubuntu. Todas las entregas se realizar\u00e1n a trav\u00e9s de Github. Contamos con varias opciones para que trabaje: Docker: Se le proveer\u00e1 un contenedor con todo el material necesario listo para usarse. El staff de la clase dar\u00e1 soporte \u00fanicamente para esta opci\u00f3n. M\u00e1quina virtual: Tendremos disponible una m\u00e1quina virtual con todo el material instalado. No se dar\u00e1 soporte a VMware. Nativo: Contamos tambi\u00e9n con un script para instalar el material necesario en Ubuntu 24.04. No se dar\u00e1 soporte a instalaciones nativas. El material que se incluye es: C\u00f3digo base para empezar sus fases del proyecto. Compilador coolc-rv para compilar de COOL hacia RISC-V y jupitercl para ejectuar Jupiter desde la terminal con un runtime apto para nuestros programas de COOL. Herramientas varias como git , make , gcc , jLex , cup y Java . Opci\u00f3n 1: Docker y contenedor \u00b6 Antes de empezar con Docker lea todas las instrucciones de esta secci\u00f3n . Instalando Docker \u00b6 Paso 1: Descargue e instale Docker Desktop: Docker Desktop Paso 2: Al finalizar el instalador le pedir\u00e1 que reinicie su m\u00e1quina. Reinicie para poder continuar. Paso 3: Despu\u00e9s de reiniciar deber\u00eda abrirse una terminal de Windows y una ventana de Docker Desktop. Si alguna de estas no se abre, ejecute manualmente Docker Desktop. Terminal de Windows No haga nada a\u00fan en Docker Desktop. Vaya primero a la terminal de Windows. Paso 4: La terminal le dar\u00e1 las instrucciones para instalar o activar WSL. Siga esas instrucciones, por lo general solo le pedir\u00e1 que presione alguna tecla para continuar y espere mientras se descarga, instala y activa. Terminal de Windows Continue en Docker Desktop solo si ya tiene listo WSL. Paso 5: Docker Desktop le pedir\u00e1 que cree una cuenta, puede usar cualquier correo para esto. Paso 6: Listo. Docker ya est\u00e1 instalado y listo para funcionar. Usando Docker \u00b6 Paso 0: Instale Git en Windows si a\u00fan no lo tiene. Git para Windows Git vs Github Se le pide instalar Git. Git es una herramienta de c\u00f3digo abierto que usaremos desde la terminal. Github tambi\u00e9n ofrece una herramienta llamada Github Desktop. En clase no usaremos esta herramienta, todo lo trabajamos desde la terminal. Paso 1: Use su terminal de Windows para clonar el siguiente repositorio: git clone https://github.com/cc-4/container Paso 2: Explore el repositorio reci\u00e9n clonado: workspace Carpeta que contiene un README. Dentro de esta carpeta quedar\u00e1n todos sus archivos como laboratorios, proyectos, etc. Usted puede acceder a esta carpeta tanto desde Windows como desde Linux. Dockerfile Archivo de texto con las instrucciones para que Docker cree su contenedor. create.bat Archivo ejecutable para que Docker cree su contenedor siguiendo las instrucciones del Dockerfile. Si hace doble clic, este se ejecuta en la terminal de Windows. run.bat Archivo ejecutable para que su contenedor se ejecute. Si hace doble clic, abre una terminal de Windows que est\u00e1 \"conectada\" con su contenedor. stop.bat Archivo ejecutable para detener su contenedor. Cuando termine de trabajar use este archivo para detener el contenedor y que este no ocupe recursos de su m\u00e1quina. Paso 3: Aseg\u00farese que Docker Desktop est\u00e1 corriendo en su m\u00e1quina. Ejecute create.bat . Esto de forma autom\u00e1tica descargar\u00e1 e instalar\u00e1 todo el material dentro de un contenedor . Cree el contenedor una sola vez Solo necesita crear el contenedor una vez. Bueno... si sufre alg\u00fan problema mayor, la soluci\u00f3n m\u00e1s sencilla ser\u00e1 eliminar el contenedor anterior y crearlo de nuevo. Paso 4: Despu\u00e9s de unos minutos de espera, su contenedor deber\u00eda ya estar listo. Notar\u00e1 que la terminal no muestra su usuario de Windows sino muestra root . Cuando vea esto sabr\u00e1 que est\u00e1 dentro del contenedor, es decir, est\u00e1 trabajando en Linux. Paso 5: Si se le cierra esa terminal, o la pr\u00f3xima vez que vaya a trabajar, use run.bat . Este autom\u00e1ticamente detecta si el contenedor ya est\u00e1 iniciado y abre una terminal conectada a este. Paso 6: Cuando termine de trabajar puede usar stop.bat para detener su contenedor. Se recomienda siempre hacerlo para ahorrar recursos, sin embargo no hay mayor problema si se le olvida. Paso 7: Listo. Por el momento ya sabe lo necesario para empezar a trabajar en Docker. M\u00e1s adelante en el semestre veremos un poco m\u00e1s sobre contenedores. Opci\u00f3n 2: M\u00e1quina Virtual \u00b6 La m\u00e1quina virtual la pueden descargar desde cualquiera de los siguientes enlaces. M\u00e1quina virtual 2025 - Google Drive M\u00e1quina virtual 2025 - Mega Es una m\u00e1quina virtual de Ubuntu 24.04 LTS para ejecutarse en VMware Workstation Pro, despu\u00e9s de descargar el archivo debe descomprimirlo y abrir el archivo .vmx que le permitir\u00e1 usar la m\u00e1quina virtual desde su VMware. Utilice VMware Workstation Pro, no utilice la versi\u00f3n Player. Si no lo tiene puede descargarlo en el siguiente enlace o buscarlo en el sitio de Broadcom. VMware Workstation Pro - Google Drive VMware Workstation Pro - Broadcom Contrase\u00f1a La contrase\u00f1a de la m\u00e1quina virtual es student Soporte La herramienta oficial para CC4 es Docker. No daremos soporte de forma oficial a la m\u00e1quina virtual. Si nos pregunta alguna duda intentaremos resolverla, pero si el problema persiste le pediremos que se cambie a Docker. Opci\u00f3n 3: Nativo \u00b6 Para esta opci\u00f3n se asume que tienen ya una m\u00e1quina con Ubuntu 24.04 LTS instalado. Debe descargar el script correspondiente desde Material de Apoyo en su GES. Luego abra una terminal y ejecute lo siguiente: chmod u+x install24.sh ./install24.sh Esto descargar\u00e1 e instalar\u00e1 todas las herramientas a su m\u00e1quina. Soporte La herramienta oficial para CC4 es Docker. No daremos soporte de forma oficial a instalaci\u00f3n nativa. Si nos pregunta alguna duda intentaremos resolverla, pero si el problema persiste le pediremos que se cambie a Docker. Estructura del proyecto \u00b6 Su proyecto consta de cuatro fases, cada una se realizar\u00e1 dentro de su propia carpeta. PA1 An\u00e1lisis l\u00e9xico (lexer) PA2 An\u00e1lisis sint\u00e1ctico (parser) PA3 An\u00e1lisis sem\u00e1ntico (semant) PA4 Generaci\u00f3n de c\u00f3digo (codegen) Estas cuatro carpetas se encontrar\u00e1n dentro de la carpeta de su repositorio de proyecto. En clases se les dar\u00e1 instrucciones para crear los grupos y obtener esta carpeta. Si usted est\u00e1 trabajando en Docker, la carpeta de su proyecto con las subcarpetas PA1...PA4 quedar\u00e1n dentro de workspace .","title":"0: Instalacion"},{"location":"projs/proj00/#instalacion-de-material","text":"Sus laboratorios y proyectos de CC4 se trabajar\u00e1n en Ubuntu. Todas las entregas se realizar\u00e1n a trav\u00e9s de Github. Contamos con varias opciones para que trabaje: Docker: Se le proveer\u00e1 un contenedor con todo el material necesario listo para usarse. El staff de la clase dar\u00e1 soporte \u00fanicamente para esta opci\u00f3n. M\u00e1quina virtual: Tendremos disponible una m\u00e1quina virtual con todo el material instalado. No se dar\u00e1 soporte a VMware. Nativo: Contamos tambi\u00e9n con un script para instalar el material necesario en Ubuntu 24.04. No se dar\u00e1 soporte a instalaciones nativas. El material que se incluye es: C\u00f3digo base para empezar sus fases del proyecto. Compilador coolc-rv para compilar de COOL hacia RISC-V y jupitercl para ejectuar Jupiter desde la terminal con un runtime apto para nuestros programas de COOL. Herramientas varias como git , make , gcc , jLex , cup y Java .","title":"Instalaci\u00f3n de material"},{"location":"projs/proj00/#opcion-1-docker-y-contenedor","text":"Antes de empezar con Docker lea todas las instrucciones de esta secci\u00f3n .","title":"Opci\u00f3n 1: Docker y contenedor"},{"location":"projs/proj00/#instalando-docker","text":"Paso 1: Descargue e instale Docker Desktop: Docker Desktop Paso 2: Al finalizar el instalador le pedir\u00e1 que reinicie su m\u00e1quina. Reinicie para poder continuar. Paso 3: Despu\u00e9s de reiniciar deber\u00eda abrirse una terminal de Windows y una ventana de Docker Desktop. Si alguna de estas no se abre, ejecute manualmente Docker Desktop. Terminal de Windows No haga nada a\u00fan en Docker Desktop. Vaya primero a la terminal de Windows. Paso 4: La terminal le dar\u00e1 las instrucciones para instalar o activar WSL. Siga esas instrucciones, por lo general solo le pedir\u00e1 que presione alguna tecla para continuar y espere mientras se descarga, instala y activa. Terminal de Windows Continue en Docker Desktop solo si ya tiene listo WSL. Paso 5: Docker Desktop le pedir\u00e1 que cree una cuenta, puede usar cualquier correo para esto. Paso 6: Listo. Docker ya est\u00e1 instalado y listo para funcionar.","title":"Instalando Docker"},{"location":"projs/proj00/#usando-docker","text":"Paso 0: Instale Git en Windows si a\u00fan no lo tiene. Git para Windows Git vs Github Se le pide instalar Git. Git es una herramienta de c\u00f3digo abierto que usaremos desde la terminal. Github tambi\u00e9n ofrece una herramienta llamada Github Desktop. En clase no usaremos esta herramienta, todo lo trabajamos desde la terminal. Paso 1: Use su terminal de Windows para clonar el siguiente repositorio: git clone https://github.com/cc-4/container Paso 2: Explore el repositorio reci\u00e9n clonado: workspace Carpeta que contiene un README. Dentro de esta carpeta quedar\u00e1n todos sus archivos como laboratorios, proyectos, etc. Usted puede acceder a esta carpeta tanto desde Windows como desde Linux. Dockerfile Archivo de texto con las instrucciones para que Docker cree su contenedor. create.bat Archivo ejecutable para que Docker cree su contenedor siguiendo las instrucciones del Dockerfile. Si hace doble clic, este se ejecuta en la terminal de Windows. run.bat Archivo ejecutable para que su contenedor se ejecute. Si hace doble clic, abre una terminal de Windows que est\u00e1 \"conectada\" con su contenedor. stop.bat Archivo ejecutable para detener su contenedor. Cuando termine de trabajar use este archivo para detener el contenedor y que este no ocupe recursos de su m\u00e1quina. Paso 3: Aseg\u00farese que Docker Desktop est\u00e1 corriendo en su m\u00e1quina. Ejecute create.bat . Esto de forma autom\u00e1tica descargar\u00e1 e instalar\u00e1 todo el material dentro de un contenedor . Cree el contenedor una sola vez Solo necesita crear el contenedor una vez. Bueno... si sufre alg\u00fan problema mayor, la soluci\u00f3n m\u00e1s sencilla ser\u00e1 eliminar el contenedor anterior y crearlo de nuevo. Paso 4: Despu\u00e9s de unos minutos de espera, su contenedor deber\u00eda ya estar listo. Notar\u00e1 que la terminal no muestra su usuario de Windows sino muestra root . Cuando vea esto sabr\u00e1 que est\u00e1 dentro del contenedor, es decir, est\u00e1 trabajando en Linux. Paso 5: Si se le cierra esa terminal, o la pr\u00f3xima vez que vaya a trabajar, use run.bat . Este autom\u00e1ticamente detecta si el contenedor ya est\u00e1 iniciado y abre una terminal conectada a este. Paso 6: Cuando termine de trabajar puede usar stop.bat para detener su contenedor. Se recomienda siempre hacerlo para ahorrar recursos, sin embargo no hay mayor problema si se le olvida. Paso 7: Listo. Por el momento ya sabe lo necesario para empezar a trabajar en Docker. M\u00e1s adelante en el semestre veremos un poco m\u00e1s sobre contenedores.","title":"Usando Docker"},{"location":"projs/proj00/#opcion-2-maquina-virtual","text":"La m\u00e1quina virtual la pueden descargar desde cualquiera de los siguientes enlaces. M\u00e1quina virtual 2025 - Google Drive M\u00e1quina virtual 2025 - Mega Es una m\u00e1quina virtual de Ubuntu 24.04 LTS para ejecutarse en VMware Workstation Pro, despu\u00e9s de descargar el archivo debe descomprimirlo y abrir el archivo .vmx que le permitir\u00e1 usar la m\u00e1quina virtual desde su VMware. Utilice VMware Workstation Pro, no utilice la versi\u00f3n Player. Si no lo tiene puede descargarlo en el siguiente enlace o buscarlo en el sitio de Broadcom. VMware Workstation Pro - Google Drive VMware Workstation Pro - Broadcom Contrase\u00f1a La contrase\u00f1a de la m\u00e1quina virtual es student Soporte La herramienta oficial para CC4 es Docker. No daremos soporte de forma oficial a la m\u00e1quina virtual. Si nos pregunta alguna duda intentaremos resolverla, pero si el problema persiste le pediremos que se cambie a Docker.","title":"Opci\u00f3n 2: M\u00e1quina Virtual"},{"location":"projs/proj00/#opcion-3-nativo","text":"Para esta opci\u00f3n se asume que tienen ya una m\u00e1quina con Ubuntu 24.04 LTS instalado. Debe descargar el script correspondiente desde Material de Apoyo en su GES. Luego abra una terminal y ejecute lo siguiente: chmod u+x install24.sh ./install24.sh Esto descargar\u00e1 e instalar\u00e1 todas las herramientas a su m\u00e1quina. Soporte La herramienta oficial para CC4 es Docker. No daremos soporte de forma oficial a instalaci\u00f3n nativa. Si nos pregunta alguna duda intentaremos resolverla, pero si el problema persiste le pediremos que se cambie a Docker.","title":"Opci\u00f3n 3: Nativo"},{"location":"projs/proj00/#estructura-del-proyecto","text":"Su proyecto consta de cuatro fases, cada una se realizar\u00e1 dentro de su propia carpeta. PA1 An\u00e1lisis l\u00e9xico (lexer) PA2 An\u00e1lisis sint\u00e1ctico (parser) PA3 An\u00e1lisis sem\u00e1ntico (semant) PA4 Generaci\u00f3n de c\u00f3digo (codegen) Estas cuatro carpetas se encontrar\u00e1n dentro de la carpeta de su repositorio de proyecto. En clases se les dar\u00e1 instrucciones para crear los grupos y obtener esta carpeta. Si usted est\u00e1 trabajando en Docker, la carpeta de su proyecto con las subcarpetas PA1...PA4 quedar\u00e1n dentro de workspace .","title":"Estructura del proyecto"},{"location":"projs/proj01/","text":"An\u00e1lisis L\u00e9xico \u00b6 Para esta asignaci\u00f3n, van a escribir un analizador l\u00e9xico, tambi\u00e9n llamado lexer, utilizando un generador de analizadores l\u00e9xicos llamado JLex . Ustedes van a describir el set de tokens para COOL en un formato adecuado y JLex va a generar el c\u00f3digo de Java para reconocer tokens en programas escritos en COOL. La documentaci\u00f3n para las herramientas est\u00e1 abajo en la secci\u00f3n de Referencias. 1. Introducci\u00f3n a JLex \u00b6 JLex permite implementar un analizador l\u00e9xico escribiendo expresiones regulares y establecer acciones cuando alguna secuencia de caracteres hace match con alguna de estas. JLex convierte estas reglas que ustedes van a definir en un archivo llamado lexer.lex en un archivo de Java con el c\u00f3digo que implementa un aut\u00f3mata finito que puede reconocer estas expresiones regulares que ustedes especificaron en el archivo lexer.lex . Afortunadamente, no es necesario entender o incluso mirar lo que autom\u00e1ticamente genera JLex. Los archivos que entiende JLex estan estructurados de la siguiente manera: %{ Declaraciones %} Definiciones %% Reglas %% Subrutinas de Usuario Las secciones de Declaraciones y Subrutinas de Usuario son opcionales y les permite a ustedes escribir declaraciones y funciones de ayuda en Java. Las secci\u00f3n de Definiciones tambi\u00e9n es opcional, pero en general es bastante \u00fatil porque las definiciones les permiten a ustedes darle nombres a las expresiones regulares. Por ejemplo, la siguiente definici\u00f3n: DIGIT = [ 0 - 9 ] Les permite definir un d\u00edgito. Aqu\u00ed, DIGIT es el nombre que se le da a la expresi\u00f3n regular que hace match con cualquier caracter que est\u00e9 entre 0 y 9. La siguiente tabla les da una vista general de expresiones regulares comunes que pueden ser especificadas en JLex. Expresi\u00f3n Descripci\u00f3n x el caracter x \"x\" caracter x , incluso si x es un operador \\x caracter x , incluso si x es un operador [xy] el caracter x o y [x-z] los caracteres x , y , z [^x] cualquier caracter excepto x . cualquier caracter excepto newline ^x caracter x al inicio de una linea <y>x caracter x cuando JLex esta en el estado <y> x$ caracter x al final de una linea x? el caracter x es opcional x* el caracter x aparece 0 o m\u00e1s veces x+ el caracter x aparece 1 o m\u00e1s veces x|y caracter x o y (x) caracter x x/y caracter x si y solo si es seguido de un caracter y {xx} hace referencia a la definici\u00f3n xx x{m,n} caracter x aparece entre m y n veces La parte m\u00e1s importante de su analizador l\u00e9xico es la secci\u00f3n de reglas. Una regla en JLex especifica una acci\u00f3n a tomar si la entrada hace match con la expresi\u00f3n regular o definici\u00f3n al principio de la regla. La acci\u00f3n a tomar es especificada escribiendo c\u00f3digo de Java regular. Por ejemplo, asumiendo que un d\u00edgito representa un token en nuestro lenguaje (noten que este no es el caso de COOL), la regla ser\u00eda entonces: { DIGIT } { AbstractSymbol num = AbstractTable . inttable . addString ( yytext ()); return new Symbol ( TokenConstants . INT_CONST , num ); } Esta regla guarda el valor del d\u00edgito en una variable global AbstractTable.inttable y retorna el c\u00f3digo apropiado para el token. Java Vean la secci\u00f3n Notas de Java para una discusi\u00f3n m\u00e1s detallada de la variable global AbstractTable.inttable y vean la secci\u00f3n Tabla de Strings para una discusi\u00f3n sobre como AbstractTable.inttable es utilizado en el c\u00f3digo de arriba. Un punto importante a recordar es que la entrada actual (es decir, el resultado de llamar a la funci\u00f3n next_token() ) puede hacer match con m\u00faltiples reglas, JLex toma la regla que hace match con el mayor n\u00famero de caracteres. Por ejemplo, si ustedes definieran las siguientes dos reglas: [ 0 - 9 ]+ { // action 1 } [ 0 - 9 a - z ]+ { // action 2 } y si la secuencia de caracteres \"2a\" aparece en el archivo que est\u00e1 siendo analizado, entonces la acci\u00f3n 2 va a tomarse, dado que la segunda regla hace match con m\u00e1s caracteres que la primer regla. Si m\u00faltiples reglas hacen match con la misma cantidad de caracteres, entonces la regla que aparece primero es la que se toma. Cuando escriban reglas en JLex, va a ser necesario que se tomen diferentes acciones dependiendo de los tokens encontrados anteriormente. Por ejemplo, cuando esten procesando un token que representa el cierre de un comentario , a ustedes les va a interesar saber si un token que representa abrir comentario se ha encontrado anteriormente. Usted podr\u00eda implementar esto con algunas variables globales en la secci\u00f3n de declaraciones y cambiarlas cuando ciertos tokens de inter\u00e9s son encontrados, sin embargo, JLex le facilita esto mediante los estados: % state COMMENT Usted puede moverse a este estado escribiendo yybegin(COMMENT) . Para tomar una acci\u00f3n si y solo si un token que representa abrir comentario ha sido encontrado anteriormente, usted usar\u00eda la siguiente sintaxis: < COMMENT > reg_exp { // action } Hay un estado default llamado YINITIAL que est\u00e1 activo al inicio, hasta que ustedes se mueven a otro utilizando yybegin(STATE) . Ustedes pueden encontrar \u00fatil esta sintaxis para varios aspectos de esta asignaci\u00f3n, as\u00ed como reportar errores. Nosotros les recomendamos que lean detenidamente la documentaci\u00f3n de JLex antes de empezar a escribir su analizador l\u00e9xico. 2. Archivos y Directorios \u00b6 Para este punto ya debe tener instalado el material. Instalaci\u00f3n de material Vaya a su carpeta PA1 y ADENTRO de esta ejecute este comando: make -f /usr/class/cc4/assignments/PA1/Makefile Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool.lex : Este archivo contiene un esqueleto para una descripci\u00f3n l\u00e9xica de COOL. Hay comentarios que indican donde ustedes tienen que llenar con c\u00f3digo, pero esto no es necesariamente una gu\u00eda completa. Una parte de la asignaci\u00f3n es que ustedes se aseguren que tienen un analizador l\u00e9xico funcional. Exceptuando las secciones indicadas, ustedes son libres de hacer modificaciones a todo el archivo. El archivo tal como viene ya permite generar un analizador l\u00e9xico, pero este no har\u00e1 casi nada todav\u00eda. Cualquier funci\u00f3n de ayuda que ustedes deseen escribir tiene que ser a\u00f1adida directamente a este archivo en la secci\u00f3n apropiada (vean los comentarios en el archivo). test.cl : Este archivo contiene un programa de COOL ejemplo para que sea analizado. Este archivo no representa toda la especificaci\u00f3n l\u00e9xica del lenguaje COOL, pero de todas maneras es una prueba interesante. Si\u00e9ntanse libres de modificar este archivo para probar su analizador l\u00e9xico. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer. Otros archivos No modifiquen ning\u00fan archivo que no se menciona en el listado, cuando se evalue la asignaci\u00f3n \u00fanicamente se va a probar el archivo cool.lex en un nuevo entorno. 3. Resultados del Lexer \u00b6 Antes de empezar con esta asignaci\u00f3n, estudien los diferentes tokens que est\u00e1n definidos en el archivo TokenConstants.java . En esta asignaci\u00f3n, ustedes tiene que escribir reglas de JLex que correspondan con todos los tokens validos en COOL, como se describe en la secci\u00f3n n\u00famero 10 y figura 1 del manual de COOL. Para cada tipo de token deben tomar las acciones apropiadas, como retornar un Symbol del tipo correcto, guardar el valor del lexema cuando sea necesario, o reportar un error cuando estos se presenten. Por ejemplo, si ustedes hacen match del token BOOL_CONST , su analizador l\u00e9xico tiene que guardar el su valor ya sea que sea true o false . Otro ejemplo, si hacen match con el token TYPEID , ustedes van a tener que guardar el nombre del tipo. Noten que no todos los tokens requieren que se guarde informaci\u00f3n adicional, por ejemplo, es suficiente que solo se devuelva el tipo de token con el que se hizo match cuando se hace match con alg\u00fan keyword del lenguaje como class . Su lexer debe de ser robusto, deber\u00eda de funcionar con cualquier input. Por ejemplo, deber\u00edan de manejar errores como cuando se encuentra un caracter de EOF en medio de un string o comentario, error por un string demasiado largo, etc.. Estos son solo algunos de los errores que pueden ser encontrados, lean el manual para conocer el resto. Ustedes tienen que terminar su an\u00e1lisis de forma elegante si alg\u00fan error fatal ocurre. Las excepciones no manejadas NO son aceptables. 3.1 Manejo de Errores \u00b6 Todos los errores deber\u00edan de ser pasados al parser. Su lexer no deber\u00eda de imprimir NADA . Los errores se comunican al parser retornando un token de error especial llamado ERROR , en may\u00fascula, junto con el mensaje de error. error en min\u00fascula Ignoren el token error en min\u00fascula durante su fase 1, lo utilizamos hasta la fase siguiente. Ignoren tambi\u00e9n el token LET_STMT . A continuaci\u00f3n informaci\u00f3n sobre los errores en strings reportar, y su recuperaci\u00f3n: Cuando un caracter inv\u00e1lido (alguno que no puede ser alg\u00fan token) se encuentra, un string que contenga solo ese caracter deber\u00eda de ser retornado como el error. Tienen que continuar el an\u00e1lisis con el siguiente caracter. Si un string contiene un newline sin escape ( \\\\ ), tienen que reportar el error como \"Unterminated string constant\" y continuar el an\u00e1lisis l\u00e9xico al principio de la siguiente l\u00ednea. Es decir, estamos asumiendo que el usuario simplemente olvido cerrar el string con una comilla. Cuando un string es demasiado largo, tienen que reportar el error \"String constant too long\" . Si el string contiene el caracter nulo \\\\0 , tienen que reportar esto como \"String contains null character\" . En cualquier caso, el an\u00e1lisis deber\u00eda de continuar hasta el final del string. El final del string es definido tanto como: El principio de la siguiente l\u00ednea si un newline es encontrado despu\u00e9s de encontrar el error. Despu\u00e9s de cerrar el string con \" . Otros errores que debe reportar: Si un comentario est\u00e1 abierto y se encuentra el caracter EOF , se tiene que reportar este error con \"EOF in comment\" . Por favor no tokenizen el contenido de los comentarios simplemente porque no se ha cerrado. De forma similiar en los strings, si un EOF es encontrado, reporten el error como \"EOF in string constant\" . Si miran un *) fuera de un comentario, tienen que reportar el error como \"Unmatched *)\" , en vez de tokenizar esta secuencia de caracteres como * y ) . Recuerden, esta fase del compilador solo detecta una cantidad limitada de errores. No tomen en cuenta ni verifiquen errores que no son errores l\u00e9xicos en esta fase. Por ejemplo, no deber\u00edan de verificar si las variables han sido declaradas anteriormente. Aseg\u00farense de entender que errores la fase de an\u00e1lisis l\u00e9xico puede considerar y cuales no antes de empezar. 3.2 Tabla de Strings \u00b6 Los programas suelen tener muchas ocurrencias del mismo lexema. Por ejemplo, un identificador es generalmente referenciado m\u00faltiples veces dentro de un programa (de lo contrario no ser\u00eda muy \u00fatil). Para ahorrarnos un poco de espacio y tiempo, una pr\u00e1ctica com\u00fan en compiladores es guardar los lexemas en una tabla de strings. Nosotros les proveemos una implementaci\u00f3n en Java para esto. Vean las siguientes secciones para m\u00e1s detalles. En fases siguientes tendremos que manejar los identificadores especiales como Object, Int, Bool, String, SELF_TYPE y self. En esta fase no debe hacer nada especial con ellos. No verifiquen que las literales enteras caben dentro de la representaci\u00f3n especificada en el manual de COOL. Simplemente creen un Symbol con el literal completo como el contenido del token, sin importar su tama\u00f1o. 3.3 Strings \u00b6 Su analizador l\u00e9xico deberia de convertir los caracteres que se les antepone un caracter de escape en las constantes string a sus valores correctos. Por ejemplo, si el programador escribe los siguientes ocho caracteres: Su analizador l\u00e9xico va a retornar un token STR_CONST cuyo valor sem\u00e1ntico es estos 5 caracteres: Donde \\n representa el caracter de newline de la tabla ASCII. Siguiendo la especificaci\u00f3n de la p\u00e1gina 15 del manual de COOL, ustedes deber\u00edan de retornar un error para un string que contenga el caracter null. Sin embargo, la secuencia de estos dos caracteres: Deber\u00eda de ser convertida a un caracter: 3.4 Otros detalles del lexer \u00b6 Su analizador l\u00e9xico deber\u00eda de mantener una variable llamada curr_lineno , que indica que l\u00ednea del archivo de entrada est\u00e1 siendo analizada. Esto va a ayudar al parser a imprimir mensajes de error \u00fatiles. Ignoren el token LET_STMT , es utilizado \u00fanicamente por el parser. Finalmente, noten que si la especificaci\u00f3n l\u00e9xica est\u00e1 incompleta (algunas entradas no tienen expresiones regulares que hagan match), entonces el lexer generado por JLex va a realizar cosas no deseables. Aseg\u00farense de que su especificaci\u00f3n est\u00e9 completa. 4. Notas de Java \u00b6 Cada llamada al lexer retorna el siguiente token y lexema de la entrada. El valor retornado por el m\u00e9todo CoolLexer.next_token es un objeto de la clase java_cup.runtime.Symbol . Este objeto tiene un campo que representa el tipo del token (por ejemplo si es un entero, punto y coma, dos puntos, etc). Los tipos de cada token est\u00e1n definidos en el archivo TokenConstants.java . El lexema (si el token tiene) tambi\u00e9n es colocado en el objeto java_cup.runtime.Symbol . La documentaci\u00f3n para la clase java_cup.runtime.Symbol est\u00e1 disponible en las referencias. Para los identificadores de clase, de objeto, enteros y strings, el lexema al final queda con el tipo AbstractSymbol . Para las constantes booleanas, el lexema queda con el tipo java.lang.Boolean . Excepto para los errores (vean abajo), los lexemas para otros tokens no tienen ninguna informaci\u00f3n interesante. Dado que el campo value en la clase java_cup.runtime.Symbol es de tipo Object, ustedes van a necesitar castear este valor antes de utilizarlo en fases posteriores. Nosotros les proveemos una implementaci\u00f3n para esto, que esta definida en el archivo AbstractTable.java . Ustedes usaran las tablas idtable , inttable y stringtable que all\u00ed se encuentran. Cuando un error l\u00e9xico occura, la rutina CoolLexer.next_token deber\u00eda de retornar un java_cup.runtime.Symbol cuyo tipo es TokenConstants.ERROR y cuyo lexema es el mensaje de error. 5. Probando su Lexer \u00b6 Hay dos maneras en la que ustedes pueden probar su analizador l\u00e9xico. La primer forma es generar archivos de entrada y correrlos utilizando su lexer, que imprime la l\u00ednea y el lexema de cada token encontrado por su lexer. La otra forma, cuando piensen que su lexer est\u00e9 funcionando correctamente, prueben correr ./mycoolc para correr su lexer junto con otras fases del compilador (que nosotros les proveemos). 6. Autograder \u00b6 El autograder se subir\u00e1 en el GES cuando veamos un avance significativo en sus proyectos. Deben hacer muchas pruebas de forma manual antes de empezar con el autograder. Cuando est\u00e9n listos para utilizarlo, primero deben darle permiso de ejecuci\u00f3n\u00d1 chmod +x pa1-grading.pl Cada vez que quieran ejecutar el autograder deber\u00edan de hacer lo siguiente: ./pa1-grading.pl Referencias \u00b6 JFlex Manual - Manual de JLex. The Cool Reference Manual - Manual de COOL. Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL.","title":"1: Lexer"},{"location":"projs/proj01/#analisis-lexico","text":"Para esta asignaci\u00f3n, van a escribir un analizador l\u00e9xico, tambi\u00e9n llamado lexer, utilizando un generador de analizadores l\u00e9xicos llamado JLex . Ustedes van a describir el set de tokens para COOL en un formato adecuado y JLex va a generar el c\u00f3digo de Java para reconocer tokens en programas escritos en COOL. La documentaci\u00f3n para las herramientas est\u00e1 abajo en la secci\u00f3n de Referencias.","title":"An\u00e1lisis L\u00e9xico"},{"location":"projs/proj01/#1-introduccion-a-jlex","text":"JLex permite implementar un analizador l\u00e9xico escribiendo expresiones regulares y establecer acciones cuando alguna secuencia de caracteres hace match con alguna de estas. JLex convierte estas reglas que ustedes van a definir en un archivo llamado lexer.lex en un archivo de Java con el c\u00f3digo que implementa un aut\u00f3mata finito que puede reconocer estas expresiones regulares que ustedes especificaron en el archivo lexer.lex . Afortunadamente, no es necesario entender o incluso mirar lo que autom\u00e1ticamente genera JLex. Los archivos que entiende JLex estan estructurados de la siguiente manera: %{ Declaraciones %} Definiciones %% Reglas %% Subrutinas de Usuario Las secciones de Declaraciones y Subrutinas de Usuario son opcionales y les permite a ustedes escribir declaraciones y funciones de ayuda en Java. Las secci\u00f3n de Definiciones tambi\u00e9n es opcional, pero en general es bastante \u00fatil porque las definiciones les permiten a ustedes darle nombres a las expresiones regulares. Por ejemplo, la siguiente definici\u00f3n: DIGIT = [ 0 - 9 ] Les permite definir un d\u00edgito. Aqu\u00ed, DIGIT es el nombre que se le da a la expresi\u00f3n regular que hace match con cualquier caracter que est\u00e9 entre 0 y 9. La siguiente tabla les da una vista general de expresiones regulares comunes que pueden ser especificadas en JLex. Expresi\u00f3n Descripci\u00f3n x el caracter x \"x\" caracter x , incluso si x es un operador \\x caracter x , incluso si x es un operador [xy] el caracter x o y [x-z] los caracteres x , y , z [^x] cualquier caracter excepto x . cualquier caracter excepto newline ^x caracter x al inicio de una linea <y>x caracter x cuando JLex esta en el estado <y> x$ caracter x al final de una linea x? el caracter x es opcional x* el caracter x aparece 0 o m\u00e1s veces x+ el caracter x aparece 1 o m\u00e1s veces x|y caracter x o y (x) caracter x x/y caracter x si y solo si es seguido de un caracter y {xx} hace referencia a la definici\u00f3n xx x{m,n} caracter x aparece entre m y n veces La parte m\u00e1s importante de su analizador l\u00e9xico es la secci\u00f3n de reglas. Una regla en JLex especifica una acci\u00f3n a tomar si la entrada hace match con la expresi\u00f3n regular o definici\u00f3n al principio de la regla. La acci\u00f3n a tomar es especificada escribiendo c\u00f3digo de Java regular. Por ejemplo, asumiendo que un d\u00edgito representa un token en nuestro lenguaje (noten que este no es el caso de COOL), la regla ser\u00eda entonces: { DIGIT } { AbstractSymbol num = AbstractTable . inttable . addString ( yytext ()); return new Symbol ( TokenConstants . INT_CONST , num ); } Esta regla guarda el valor del d\u00edgito en una variable global AbstractTable.inttable y retorna el c\u00f3digo apropiado para el token. Java Vean la secci\u00f3n Notas de Java para una discusi\u00f3n m\u00e1s detallada de la variable global AbstractTable.inttable y vean la secci\u00f3n Tabla de Strings para una discusi\u00f3n sobre como AbstractTable.inttable es utilizado en el c\u00f3digo de arriba. Un punto importante a recordar es que la entrada actual (es decir, el resultado de llamar a la funci\u00f3n next_token() ) puede hacer match con m\u00faltiples reglas, JLex toma la regla que hace match con el mayor n\u00famero de caracteres. Por ejemplo, si ustedes definieran las siguientes dos reglas: [ 0 - 9 ]+ { // action 1 } [ 0 - 9 a - z ]+ { // action 2 } y si la secuencia de caracteres \"2a\" aparece en el archivo que est\u00e1 siendo analizado, entonces la acci\u00f3n 2 va a tomarse, dado que la segunda regla hace match con m\u00e1s caracteres que la primer regla. Si m\u00faltiples reglas hacen match con la misma cantidad de caracteres, entonces la regla que aparece primero es la que se toma. Cuando escriban reglas en JLex, va a ser necesario que se tomen diferentes acciones dependiendo de los tokens encontrados anteriormente. Por ejemplo, cuando esten procesando un token que representa el cierre de un comentario , a ustedes les va a interesar saber si un token que representa abrir comentario se ha encontrado anteriormente. Usted podr\u00eda implementar esto con algunas variables globales en la secci\u00f3n de declaraciones y cambiarlas cuando ciertos tokens de inter\u00e9s son encontrados, sin embargo, JLex le facilita esto mediante los estados: % state COMMENT Usted puede moverse a este estado escribiendo yybegin(COMMENT) . Para tomar una acci\u00f3n si y solo si un token que representa abrir comentario ha sido encontrado anteriormente, usted usar\u00eda la siguiente sintaxis: < COMMENT > reg_exp { // action } Hay un estado default llamado YINITIAL que est\u00e1 activo al inicio, hasta que ustedes se mueven a otro utilizando yybegin(STATE) . Ustedes pueden encontrar \u00fatil esta sintaxis para varios aspectos de esta asignaci\u00f3n, as\u00ed como reportar errores. Nosotros les recomendamos que lean detenidamente la documentaci\u00f3n de JLex antes de empezar a escribir su analizador l\u00e9xico.","title":"1. Introducci\u00f3n a JLex"},{"location":"projs/proj01/#2-archivos-y-directorios","text":"Para este punto ya debe tener instalado el material. Instalaci\u00f3n de material Vaya a su carpeta PA1 y ADENTRO de esta ejecute este comando: make -f /usr/class/cc4/assignments/PA1/Makefile Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool.lex : Este archivo contiene un esqueleto para una descripci\u00f3n l\u00e9xica de COOL. Hay comentarios que indican donde ustedes tienen que llenar con c\u00f3digo, pero esto no es necesariamente una gu\u00eda completa. Una parte de la asignaci\u00f3n es que ustedes se aseguren que tienen un analizador l\u00e9xico funcional. Exceptuando las secciones indicadas, ustedes son libres de hacer modificaciones a todo el archivo. El archivo tal como viene ya permite generar un analizador l\u00e9xico, pero este no har\u00e1 casi nada todav\u00eda. Cualquier funci\u00f3n de ayuda que ustedes deseen escribir tiene que ser a\u00f1adida directamente a este archivo en la secci\u00f3n apropiada (vean los comentarios en el archivo). test.cl : Este archivo contiene un programa de COOL ejemplo para que sea analizado. Este archivo no representa toda la especificaci\u00f3n l\u00e9xica del lenguaje COOL, pero de todas maneras es una prueba interesante. Si\u00e9ntanse libres de modificar este archivo para probar su analizador l\u00e9xico. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer. Otros archivos No modifiquen ning\u00fan archivo que no se menciona en el listado, cuando se evalue la asignaci\u00f3n \u00fanicamente se va a probar el archivo cool.lex en un nuevo entorno.","title":"2. Archivos y Directorios"},{"location":"projs/proj01/#3-resultados-del-lexer","text":"Antes de empezar con esta asignaci\u00f3n, estudien los diferentes tokens que est\u00e1n definidos en el archivo TokenConstants.java . En esta asignaci\u00f3n, ustedes tiene que escribir reglas de JLex que correspondan con todos los tokens validos en COOL, como se describe en la secci\u00f3n n\u00famero 10 y figura 1 del manual de COOL. Para cada tipo de token deben tomar las acciones apropiadas, como retornar un Symbol del tipo correcto, guardar el valor del lexema cuando sea necesario, o reportar un error cuando estos se presenten. Por ejemplo, si ustedes hacen match del token BOOL_CONST , su analizador l\u00e9xico tiene que guardar el su valor ya sea que sea true o false . Otro ejemplo, si hacen match con el token TYPEID , ustedes van a tener que guardar el nombre del tipo. Noten que no todos los tokens requieren que se guarde informaci\u00f3n adicional, por ejemplo, es suficiente que solo se devuelva el tipo de token con el que se hizo match cuando se hace match con alg\u00fan keyword del lenguaje como class . Su lexer debe de ser robusto, deber\u00eda de funcionar con cualquier input. Por ejemplo, deber\u00edan de manejar errores como cuando se encuentra un caracter de EOF en medio de un string o comentario, error por un string demasiado largo, etc.. Estos son solo algunos de los errores que pueden ser encontrados, lean el manual para conocer el resto. Ustedes tienen que terminar su an\u00e1lisis de forma elegante si alg\u00fan error fatal ocurre. Las excepciones no manejadas NO son aceptables.","title":"3. Resultados del Lexer"},{"location":"projs/proj01/#31-manejo-de-errores","text":"Todos los errores deber\u00edan de ser pasados al parser. Su lexer no deber\u00eda de imprimir NADA . Los errores se comunican al parser retornando un token de error especial llamado ERROR , en may\u00fascula, junto con el mensaje de error. error en min\u00fascula Ignoren el token error en min\u00fascula durante su fase 1, lo utilizamos hasta la fase siguiente. Ignoren tambi\u00e9n el token LET_STMT . A continuaci\u00f3n informaci\u00f3n sobre los errores en strings reportar, y su recuperaci\u00f3n: Cuando un caracter inv\u00e1lido (alguno que no puede ser alg\u00fan token) se encuentra, un string que contenga solo ese caracter deber\u00eda de ser retornado como el error. Tienen que continuar el an\u00e1lisis con el siguiente caracter. Si un string contiene un newline sin escape ( \\\\ ), tienen que reportar el error como \"Unterminated string constant\" y continuar el an\u00e1lisis l\u00e9xico al principio de la siguiente l\u00ednea. Es decir, estamos asumiendo que el usuario simplemente olvido cerrar el string con una comilla. Cuando un string es demasiado largo, tienen que reportar el error \"String constant too long\" . Si el string contiene el caracter nulo \\\\0 , tienen que reportar esto como \"String contains null character\" . En cualquier caso, el an\u00e1lisis deber\u00eda de continuar hasta el final del string. El final del string es definido tanto como: El principio de la siguiente l\u00ednea si un newline es encontrado despu\u00e9s de encontrar el error. Despu\u00e9s de cerrar el string con \" . Otros errores que debe reportar: Si un comentario est\u00e1 abierto y se encuentra el caracter EOF , se tiene que reportar este error con \"EOF in comment\" . Por favor no tokenizen el contenido de los comentarios simplemente porque no se ha cerrado. De forma similiar en los strings, si un EOF es encontrado, reporten el error como \"EOF in string constant\" . Si miran un *) fuera de un comentario, tienen que reportar el error como \"Unmatched *)\" , en vez de tokenizar esta secuencia de caracteres como * y ) . Recuerden, esta fase del compilador solo detecta una cantidad limitada de errores. No tomen en cuenta ni verifiquen errores que no son errores l\u00e9xicos en esta fase. Por ejemplo, no deber\u00edan de verificar si las variables han sido declaradas anteriormente. Aseg\u00farense de entender que errores la fase de an\u00e1lisis l\u00e9xico puede considerar y cuales no antes de empezar.","title":"3.1 Manejo de Errores"},{"location":"projs/proj01/#32-tabla-de-strings","text":"Los programas suelen tener muchas ocurrencias del mismo lexema. Por ejemplo, un identificador es generalmente referenciado m\u00faltiples veces dentro de un programa (de lo contrario no ser\u00eda muy \u00fatil). Para ahorrarnos un poco de espacio y tiempo, una pr\u00e1ctica com\u00fan en compiladores es guardar los lexemas en una tabla de strings. Nosotros les proveemos una implementaci\u00f3n en Java para esto. Vean las siguientes secciones para m\u00e1s detalles. En fases siguientes tendremos que manejar los identificadores especiales como Object, Int, Bool, String, SELF_TYPE y self. En esta fase no debe hacer nada especial con ellos. No verifiquen que las literales enteras caben dentro de la representaci\u00f3n especificada en el manual de COOL. Simplemente creen un Symbol con el literal completo como el contenido del token, sin importar su tama\u00f1o.","title":"3.2 Tabla de Strings"},{"location":"projs/proj01/#33-strings","text":"Su analizador l\u00e9xico deberia de convertir los caracteres que se les antepone un caracter de escape en las constantes string a sus valores correctos. Por ejemplo, si el programador escribe los siguientes ocho caracteres: Su analizador l\u00e9xico va a retornar un token STR_CONST cuyo valor sem\u00e1ntico es estos 5 caracteres: Donde \\n representa el caracter de newline de la tabla ASCII. Siguiendo la especificaci\u00f3n de la p\u00e1gina 15 del manual de COOL, ustedes deber\u00edan de retornar un error para un string que contenga el caracter null. Sin embargo, la secuencia de estos dos caracteres: Deber\u00eda de ser convertida a un caracter:","title":"3.3 Strings"},{"location":"projs/proj01/#34-otros-detalles-del-lexer","text":"Su analizador l\u00e9xico deber\u00eda de mantener una variable llamada curr_lineno , que indica que l\u00ednea del archivo de entrada est\u00e1 siendo analizada. Esto va a ayudar al parser a imprimir mensajes de error \u00fatiles. Ignoren el token LET_STMT , es utilizado \u00fanicamente por el parser. Finalmente, noten que si la especificaci\u00f3n l\u00e9xica est\u00e1 incompleta (algunas entradas no tienen expresiones regulares que hagan match), entonces el lexer generado por JLex va a realizar cosas no deseables. Aseg\u00farense de que su especificaci\u00f3n est\u00e9 completa.","title":"3.4 Otros detalles del lexer"},{"location":"projs/proj01/#4-notas-de-java","text":"Cada llamada al lexer retorna el siguiente token y lexema de la entrada. El valor retornado por el m\u00e9todo CoolLexer.next_token es un objeto de la clase java_cup.runtime.Symbol . Este objeto tiene un campo que representa el tipo del token (por ejemplo si es un entero, punto y coma, dos puntos, etc). Los tipos de cada token est\u00e1n definidos en el archivo TokenConstants.java . El lexema (si el token tiene) tambi\u00e9n es colocado en el objeto java_cup.runtime.Symbol . La documentaci\u00f3n para la clase java_cup.runtime.Symbol est\u00e1 disponible en las referencias. Para los identificadores de clase, de objeto, enteros y strings, el lexema al final queda con el tipo AbstractSymbol . Para las constantes booleanas, el lexema queda con el tipo java.lang.Boolean . Excepto para los errores (vean abajo), los lexemas para otros tokens no tienen ninguna informaci\u00f3n interesante. Dado que el campo value en la clase java_cup.runtime.Symbol es de tipo Object, ustedes van a necesitar castear este valor antes de utilizarlo en fases posteriores. Nosotros les proveemos una implementaci\u00f3n para esto, que esta definida en el archivo AbstractTable.java . Ustedes usaran las tablas idtable , inttable y stringtable que all\u00ed se encuentran. Cuando un error l\u00e9xico occura, la rutina CoolLexer.next_token deber\u00eda de retornar un java_cup.runtime.Symbol cuyo tipo es TokenConstants.ERROR y cuyo lexema es el mensaje de error.","title":"4. Notas de Java"},{"location":"projs/proj01/#5-probando-su-lexer","text":"Hay dos maneras en la que ustedes pueden probar su analizador l\u00e9xico. La primer forma es generar archivos de entrada y correrlos utilizando su lexer, que imprime la l\u00ednea y el lexema de cada token encontrado por su lexer. La otra forma, cuando piensen que su lexer est\u00e9 funcionando correctamente, prueben correr ./mycoolc para correr su lexer junto con otras fases del compilador (que nosotros les proveemos).","title":"5. Probando su Lexer"},{"location":"projs/proj01/#6-autograder","text":"El autograder se subir\u00e1 en el GES cuando veamos un avance significativo en sus proyectos. Deben hacer muchas pruebas de forma manual antes de empezar con el autograder. Cuando est\u00e9n listos para utilizarlo, primero deben darle permiso de ejecuci\u00f3n\u00d1 chmod +x pa1-grading.pl Cada vez que quieran ejecutar el autograder deber\u00edan de hacer lo siguiente: ./pa1-grading.pl","title":"6. Autograder"},{"location":"projs/proj01/#referencias","text":"JFlex Manual - Manual de JLex. The Cool Reference Manual - Manual de COOL. Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL.","title":"Referencias"},{"location":"projs/proj02/","text":"An\u00e1lisis Sint\u00e1ctico \u00b6 En esta asignaci\u00f3n ustedes van a escribir un parser para COOL. La asignaci\u00f3n hace uso de dos herramientas: el generador de parser cup y el paquete de Java con las clases que representan los nodos de un \u00e1rbol sint\u00e1ctico. La salida de su parser va a ser un \u00e1rbol sint\u00e1ctico abstracto o AST por sus siglas en ingl\u00e9s. Van a construir un AST utilizando acciones sem\u00e1nticas del generador de parser cup. Inicien esta fase consultando la estructura sint\u00e1ctica de COOL en la figura 1 del manual. Consulte tambi\u00e9n la documentaci\u00f3n de cup y del paquete tree, en los links al final de la p\u00e1gina. La documentaci\u00f3n del paquete tree le servir\u00e1 durante el resto del proyecto. Por favor lean este documento detenida y cuidadosamente, poni\u00e9ndole mucha atenci\u00f3n a los detalles. 1. Archivos y Directorios \u00b6 Para empezar, creen el directorio PA2 tal como se explic\u00f3 al inicio. ADENTRO de esa carpeta ejecuten el siguiente comando: make -f /usr/class/cc4/assignments/PA2/Makefile Este comando va a copiar bastantes archivos en su directorio. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool.cup : Este archivo contiene un esqueleto que describe un parser para COOL. La secci\u00f3n de declaraciones est\u00e1 casi completa, pero van a necesitar agregar alguna que otra declaraci\u00f3n para definir nuevos no terminales . Nosotros les hemos dado ya los nombres y tipos de declaraci\u00f3n para los terminales de la gram\u00e1tica. Ustedes tienen que agregar declaraciones de precedencia tambi\u00e9n. La secci\u00f3n de reglas, sin embargo, est\u00e1 incompleta. Les hemos prove\u00eddo algunas partes para algunas reglas, pero estas son solo un ejemplo. Piense bien qu\u00e9 reglas necesitar\u00e1. good.cl y bad.cl : Estos archivos prueban algunas caracter\u00edsticas de la gram\u00e1tica de COOL. Pueden modificar estos archivos como ustedes quieran para probar su parser. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer. Otros archivos No modifiquen ning\u00fan archivo que no se menciona en el listado, cuando se evalue la asignaci\u00f3n \u00fanicamente se va a probar el archivo cool.cup en un nuevo entorno. 2. Probando el Parser \u00b6 Ustedes van a necesitar un lexer completamente funcional para probar el parser. Pueden utilizar su propio analizador l\u00e9xico del proyecto pasado o utilizar el lexer de coolc-rv. Por default, el lexer de coolc-rv es utilizado, para cambiar este comportamiento, cambien el archivo ejecutable lexer (que es un enlace simb\u00f3lico en su directorio de proyecto) con su propio lexer. No asuman autom\u00e1ticamente que el lexer que utilicen est\u00e1 libre de errores. Algunos bugs latentes en el analizador l\u00e9xico pueden generar problemas misteriosos en el parser. Ustedes van a correr su parser utilizando ./myparser , un shell script que pega el parser con un analizador l\u00e9xico (el de su elecci\u00f3n). Noten que ./myparser puede recibir una bandera -p para depurar el parser. Utilizar esta bandera causa que un mont\u00f3n de informaci\u00f3n de lo que el parser est\u00e1 haciendo sea impreso en la terminal. cup produce tablas de parseo de una gram\u00e1tica LALR(1) bastante le\u00edbles en un archivo llamado cool.output . Examinar este archivo a veces puede ser \u00fatil para depurar la definici\u00f3n del parser. Ustedes deber\u00edan de probar este parser tanto en archivos bien definidos de COOL, como en malos, para ver si todo est\u00e1 funcionando correctamente. Recuerden, los bugs en su parser se pueden manifestar en alguna otra parte m\u00e1s adelante. Su parser va a ser calificado utilizando nuestro analizador l\u00e9xico, entonces si ustedes escogen utilizar unicamente su parser, sepan de antemano que esto est\u00e1 sucediendo en el autograder. Lexer Al inicio probaremos nuestra fase 2 usando el analizador l\u00e9xico de coolc-rv que viene por defecto, ya que este est\u00e1 menos propenso a errores. Cuando ya tengan un parser funcional utilicen su propio analizador l\u00e9xico para verificar que todo siga funcionando bien. 3. Salida del Parser \u00b6 Sus acciones sem\u00e1nticas deber\u00edan de construir un AST. La ra\u00edz (y solamente la ra\u00edz) del AST deber\u00eda de ser de tipo programc . Para los programas que son parseados satisfactoriamente, la salida del parser es un listado del AST. Para programas que contengan errores (l\u00e9xicos o sint\u00e1cticos), la salida son mensajes de error del parser. Nosotros les hemos prove\u00eddo con una funci\u00f3n que reporta errores imprimiendo los mensajes en un formato est\u00e1ndar, por favor NO modifiquen esto. Ustedes no deber\u00edan de invocar esta funci\u00f3n directamente en las acciones sem\u00e1nticas, cup autom\u00e1ticamente invoca a esta funci\u00f3n cuando un error es detectado. Para algunas construcciones que puedan abarcar varias l\u00edneas de c\u00f3digo, por ejemplo: foo ( 1 , 2 , 3 ) Este dispatch abarca 5 l\u00edneas, de la 1 a la 5. Ustedes cuando construyan alg\u00fan nodo que abarque m\u00faltiples l\u00edneas son libres de indicar a que n\u00famero de l\u00ednea pertence este nodo, siempre y cuando, el n\u00famero est\u00e9 en el rango que abarque el nodo, en el ejemplo anterior podr\u00eda ser 1, 2, 3, 4 o 5. No se preocupen si las l\u00edneas reportadas por su parser no hacen match exactamente como el compilador de referencia coolc-rv. Su parser solo deber\u00eda de funcionar para programas que est\u00e9n contenidos en un solo archivo. No se preocupen por compilar m\u00faltiples archivos. N\u00famero de l\u00ednea Siempre que reporten el n\u00famero de l\u00ednea utilicen la funci\u00f3n de ayuda curr_lineno() que se encuentra en cool.cup . 4. Manejo de Errores \u00b6 Ustedes deber\u00edan de utilizar el pseudo no terminal error (en min\u00fascula, el que ignoramos durante lexer) para manejar errores en el parser. El prop\u00f3sito de error es permitirle al parser continuar despu\u00e9s de un error anticipado. No es una soluci\u00f3n garantizada y el parser puede volverse completamente confuso. Vean la documentaci\u00f3n de cup para saber como utilizar error de forma eficiente. Para recibir toda la nota, su parser deber\u00eda de recuperarse por lo menos en las siguientes situaciones: Si hay alg\u00fan error en una definici\u00f3n de clase pero la clase es terminada correctamente y la siguiente clase est\u00e1 correcta sint\u00e1cticamente, el parser deber\u00eda de ser capaz de empezar de nuevo en la siguiente definici\u00f3n de clase. El parser deber\u00eda de recuperarse de errores en los features (debe irse a analizar el siguiente feature). En un let, debe pasar a la siguiente variable. En un bloque, debe ir a la siguiente expresi\u00f3n. No se preocupen demasiado por los n\u00fameros de l\u00ednea que aparecen en los mensajes de error que su parser genera. Si su parser est\u00e1 funcionando correctamente, el n\u00famero de l\u00ednea generalmente va a ser la l\u00ednea donde se encontr\u00f3 el error. Para construcciones erroneas que abarquen m\u00faltiples l\u00edneas, el n\u00famero de l\u00ednea por lo general va a ser la \u00faltima l\u00ednea de esa construcci\u00f3n. 5. Observaciones \u00b6 Ustedes van a necesitar declaraciones de precedencia, pero solo para las expresiones. No las utilicen para resolver otro tipo de problemas. El let de COOL se maneja de forma especial, revise la documentaci\u00f3n del tree y notar\u00e1 que cada let puede tener \u00fanicamente una variable asociada a este. Deber\u00e1 escribir sus reglas de tal forma que los let queden anidados para que su parser funcione. Cuando est\u00e9 listo para probar el parser usando el autograder, quite cualquier print extra que haya agregado. De igual forma, cualquier print extra o cualquier caracter extra\u00f1o puede causar problemas en fases siguientes. 6. Notas de Java \u00b6 Ustedes deber\u00edan de declarar tipos para sus no terminales y los terminales que tengan valor, por ejemplo, en el archivo cool.cup est\u00e1 la declaraci\u00f3n: nonterminal programc program ; Esta declaraci\u00f3n dice que el no terminal program tiene tipo programc . Es cr\u00edtico que ustedes declaren el tipo correcto para los atributos de los s\u00edmbolos de la gram\u00e1tica.Si no lo hace, su parser no funcionar\u00e1 correctamente. Note que tambi\u00e9n hay varios elementos que no llevan tipo. Es probable que javac se queje si utilizan los constructores de los nodos del \u00e1rbol con el tipo incorrecto. Si ustedes hacen alg\u00fan casting para resolver esto por fuerza bruta, es probable que su parser s\u00ed compile, pero lance una excepci\u00f3n al ejecutarse. 7. Autograder \u00b6 Ustedes deber\u00edan de descargar el siguiente script en el mismo directorio donde tienen sus archivos de la segunda fase, y darle permisos. wget https://cc-4.github.io/cc4/pa2-grading.pl chmod +x pa2-grading.pl Lo ejecutan de la siguiente manera: ./pa2-grading.pl Esto califica su parser utilizando el analizador l\u00e9xico de coolc. Si ustedes quieren probar su parser junto con su propia fase 1: wget https://cc-4.github.io/cc4/pa2-grading-all.sh chmod +x pa2-grading-all.sh Lo ejecutan de la siguiente manera: ./pa2-grading-all.sh Referencias \u00b6 The Tree Package - Javadoc del paquete Tree. cup Manual - Manual de JCup. The Cool Reference Manual - Manual de COOL. Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL. cup Javadoc - Javadoc de JCup.","title":"2: Parser"},{"location":"projs/proj02/#analisis-sintactico","text":"En esta asignaci\u00f3n ustedes van a escribir un parser para COOL. La asignaci\u00f3n hace uso de dos herramientas: el generador de parser cup y el paquete de Java con las clases que representan los nodos de un \u00e1rbol sint\u00e1ctico. La salida de su parser va a ser un \u00e1rbol sint\u00e1ctico abstracto o AST por sus siglas en ingl\u00e9s. Van a construir un AST utilizando acciones sem\u00e1nticas del generador de parser cup. Inicien esta fase consultando la estructura sint\u00e1ctica de COOL en la figura 1 del manual. Consulte tambi\u00e9n la documentaci\u00f3n de cup y del paquete tree, en los links al final de la p\u00e1gina. La documentaci\u00f3n del paquete tree le servir\u00e1 durante el resto del proyecto. Por favor lean este documento detenida y cuidadosamente, poni\u00e9ndole mucha atenci\u00f3n a los detalles.","title":"An\u00e1lisis Sint\u00e1ctico"},{"location":"projs/proj02/#1-archivos-y-directorios","text":"Para empezar, creen el directorio PA2 tal como se explic\u00f3 al inicio. ADENTRO de esa carpeta ejecuten el siguiente comando: make -f /usr/class/cc4/assignments/PA2/Makefile Este comando va a copiar bastantes archivos en su directorio. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool.cup : Este archivo contiene un esqueleto que describe un parser para COOL. La secci\u00f3n de declaraciones est\u00e1 casi completa, pero van a necesitar agregar alguna que otra declaraci\u00f3n para definir nuevos no terminales . Nosotros les hemos dado ya los nombres y tipos de declaraci\u00f3n para los terminales de la gram\u00e1tica. Ustedes tienen que agregar declaraciones de precedencia tambi\u00e9n. La secci\u00f3n de reglas, sin embargo, est\u00e1 incompleta. Les hemos prove\u00eddo algunas partes para algunas reglas, pero estas son solo un ejemplo. Piense bien qu\u00e9 reglas necesitar\u00e1. good.cl y bad.cl : Estos archivos prueban algunas caracter\u00edsticas de la gram\u00e1tica de COOL. Pueden modificar estos archivos como ustedes quieran para probar su parser. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Realmente este archivo no lo van a modificar, pero es bueno mencionar que lo tienen que leer. Otros archivos No modifiquen ning\u00fan archivo que no se menciona en el listado, cuando se evalue la asignaci\u00f3n \u00fanicamente se va a probar el archivo cool.cup en un nuevo entorno.","title":"1. Archivos y Directorios"},{"location":"projs/proj02/#2-probando-el-parser","text":"Ustedes van a necesitar un lexer completamente funcional para probar el parser. Pueden utilizar su propio analizador l\u00e9xico del proyecto pasado o utilizar el lexer de coolc-rv. Por default, el lexer de coolc-rv es utilizado, para cambiar este comportamiento, cambien el archivo ejecutable lexer (que es un enlace simb\u00f3lico en su directorio de proyecto) con su propio lexer. No asuman autom\u00e1ticamente que el lexer que utilicen est\u00e1 libre de errores. Algunos bugs latentes en el analizador l\u00e9xico pueden generar problemas misteriosos en el parser. Ustedes van a correr su parser utilizando ./myparser , un shell script que pega el parser con un analizador l\u00e9xico (el de su elecci\u00f3n). Noten que ./myparser puede recibir una bandera -p para depurar el parser. Utilizar esta bandera causa que un mont\u00f3n de informaci\u00f3n de lo que el parser est\u00e1 haciendo sea impreso en la terminal. cup produce tablas de parseo de una gram\u00e1tica LALR(1) bastante le\u00edbles en un archivo llamado cool.output . Examinar este archivo a veces puede ser \u00fatil para depurar la definici\u00f3n del parser. Ustedes deber\u00edan de probar este parser tanto en archivos bien definidos de COOL, como en malos, para ver si todo est\u00e1 funcionando correctamente. Recuerden, los bugs en su parser se pueden manifestar en alguna otra parte m\u00e1s adelante. Su parser va a ser calificado utilizando nuestro analizador l\u00e9xico, entonces si ustedes escogen utilizar unicamente su parser, sepan de antemano que esto est\u00e1 sucediendo en el autograder. Lexer Al inicio probaremos nuestra fase 2 usando el analizador l\u00e9xico de coolc-rv que viene por defecto, ya que este est\u00e1 menos propenso a errores. Cuando ya tengan un parser funcional utilicen su propio analizador l\u00e9xico para verificar que todo siga funcionando bien.","title":"2. Probando el Parser"},{"location":"projs/proj02/#3-salida-del-parser","text":"Sus acciones sem\u00e1nticas deber\u00edan de construir un AST. La ra\u00edz (y solamente la ra\u00edz) del AST deber\u00eda de ser de tipo programc . Para los programas que son parseados satisfactoriamente, la salida del parser es un listado del AST. Para programas que contengan errores (l\u00e9xicos o sint\u00e1cticos), la salida son mensajes de error del parser. Nosotros les hemos prove\u00eddo con una funci\u00f3n que reporta errores imprimiendo los mensajes en un formato est\u00e1ndar, por favor NO modifiquen esto. Ustedes no deber\u00edan de invocar esta funci\u00f3n directamente en las acciones sem\u00e1nticas, cup autom\u00e1ticamente invoca a esta funci\u00f3n cuando un error es detectado. Para algunas construcciones que puedan abarcar varias l\u00edneas de c\u00f3digo, por ejemplo: foo ( 1 , 2 , 3 ) Este dispatch abarca 5 l\u00edneas, de la 1 a la 5. Ustedes cuando construyan alg\u00fan nodo que abarque m\u00faltiples l\u00edneas son libres de indicar a que n\u00famero de l\u00ednea pertence este nodo, siempre y cuando, el n\u00famero est\u00e9 en el rango que abarque el nodo, en el ejemplo anterior podr\u00eda ser 1, 2, 3, 4 o 5. No se preocupen si las l\u00edneas reportadas por su parser no hacen match exactamente como el compilador de referencia coolc-rv. Su parser solo deber\u00eda de funcionar para programas que est\u00e9n contenidos en un solo archivo. No se preocupen por compilar m\u00faltiples archivos. N\u00famero de l\u00ednea Siempre que reporten el n\u00famero de l\u00ednea utilicen la funci\u00f3n de ayuda curr_lineno() que se encuentra en cool.cup .","title":"3. Salida del Parser"},{"location":"projs/proj02/#4-manejo-de-errores","text":"Ustedes deber\u00edan de utilizar el pseudo no terminal error (en min\u00fascula, el que ignoramos durante lexer) para manejar errores en el parser. El prop\u00f3sito de error es permitirle al parser continuar despu\u00e9s de un error anticipado. No es una soluci\u00f3n garantizada y el parser puede volverse completamente confuso. Vean la documentaci\u00f3n de cup para saber como utilizar error de forma eficiente. Para recibir toda la nota, su parser deber\u00eda de recuperarse por lo menos en las siguientes situaciones: Si hay alg\u00fan error en una definici\u00f3n de clase pero la clase es terminada correctamente y la siguiente clase est\u00e1 correcta sint\u00e1cticamente, el parser deber\u00eda de ser capaz de empezar de nuevo en la siguiente definici\u00f3n de clase. El parser deber\u00eda de recuperarse de errores en los features (debe irse a analizar el siguiente feature). En un let, debe pasar a la siguiente variable. En un bloque, debe ir a la siguiente expresi\u00f3n. No se preocupen demasiado por los n\u00fameros de l\u00ednea que aparecen en los mensajes de error que su parser genera. Si su parser est\u00e1 funcionando correctamente, el n\u00famero de l\u00ednea generalmente va a ser la l\u00ednea donde se encontr\u00f3 el error. Para construcciones erroneas que abarquen m\u00faltiples l\u00edneas, el n\u00famero de l\u00ednea por lo general va a ser la \u00faltima l\u00ednea de esa construcci\u00f3n.","title":"4. Manejo de Errores"},{"location":"projs/proj02/#5-observaciones","text":"Ustedes van a necesitar declaraciones de precedencia, pero solo para las expresiones. No las utilicen para resolver otro tipo de problemas. El let de COOL se maneja de forma especial, revise la documentaci\u00f3n del tree y notar\u00e1 que cada let puede tener \u00fanicamente una variable asociada a este. Deber\u00e1 escribir sus reglas de tal forma que los let queden anidados para que su parser funcione. Cuando est\u00e9 listo para probar el parser usando el autograder, quite cualquier print extra que haya agregado. De igual forma, cualquier print extra o cualquier caracter extra\u00f1o puede causar problemas en fases siguientes.","title":"5. Observaciones"},{"location":"projs/proj02/#6-notas-de-java","text":"Ustedes deber\u00edan de declarar tipos para sus no terminales y los terminales que tengan valor, por ejemplo, en el archivo cool.cup est\u00e1 la declaraci\u00f3n: nonterminal programc program ; Esta declaraci\u00f3n dice que el no terminal program tiene tipo programc . Es cr\u00edtico que ustedes declaren el tipo correcto para los atributos de los s\u00edmbolos de la gram\u00e1tica.Si no lo hace, su parser no funcionar\u00e1 correctamente. Note que tambi\u00e9n hay varios elementos que no llevan tipo. Es probable que javac se queje si utilizan los constructores de los nodos del \u00e1rbol con el tipo incorrecto. Si ustedes hacen alg\u00fan casting para resolver esto por fuerza bruta, es probable que su parser s\u00ed compile, pero lance una excepci\u00f3n al ejecutarse.","title":"6. Notas de Java"},{"location":"projs/proj02/#7-autograder","text":"Ustedes deber\u00edan de descargar el siguiente script en el mismo directorio donde tienen sus archivos de la segunda fase, y darle permisos. wget https://cc-4.github.io/cc4/pa2-grading.pl chmod +x pa2-grading.pl Lo ejecutan de la siguiente manera: ./pa2-grading.pl Esto califica su parser utilizando el analizador l\u00e9xico de coolc. Si ustedes quieren probar su parser junto con su propia fase 1: wget https://cc-4.github.io/cc4/pa2-grading-all.sh chmod +x pa2-grading-all.sh Lo ejecutan de la siguiente manera: ./pa2-grading-all.sh","title":"7. Autograder"},{"location":"projs/proj02/#referencias","text":"The Tree Package - Javadoc del paquete Tree. cup Manual - Manual de JCup. The Cool Reference Manual - Manual de COOL. Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL. cup Javadoc - Javadoc de JCup.","title":"Referencias"},{"location":"projs/proj03/","text":"An\u00e1lisis Sem\u00e1ntico \u00b6 En est\u00e1 asignaci\u00f3n, ustedes van a implementar el an\u00e1lisis sem\u00e1ntico para COOL. Ustedes van a utilizar el AST construido por el parser para verificar si el programa est\u00e1 correcto sem\u00e1nticamente siguiendo la especificaci\u00f3n de COOL. Su analizador sem\u00e1ntico deber\u00eda de rechazar programas erroneos. Para programas que est\u00e9n correctos, deber\u00eda reunir informaci\u00f3n que va a ser utilizada por el generador de c\u00f3digo. La salida del analizador sem\u00e1ntico va a ser un AST anotado utilizado por su generador de c\u00f3digo. En esta asignaci\u00f3n tiene m\u00e1s libertad para tomar decisiones de dise\u00f1o que en las \u00faltimas dos asignaciones. Su semantic va a ser correcto si puede verificar programas reflejando la especificaci\u00f3n. No hay una sola soluci\u00f3n para esta asignaci\u00f3n, pero si hay muchas malas maneras de implementarla. Hay un n\u00famero de practicas est\u00e1ndar que creemos que hacen la vida m\u00e1s f\u00e1cil, y les vamos a tratar de inculcar estas pr\u00e1cticas a ustedes. Sin embargo, lo que ustedes hagan es su responsabilidad, cualquier cosa que ustedes decidan hacer, est\u00e9n preparados para justificarla y explicarla. Ustedes van a necesitar referirse a las reglas de inferencia de tipos descritas en el manual de referencia de COOL. Ustedes tambi\u00e9n van a necesitar agregar m\u00e9todos y atributos a los nodos del AST para esta fase. Las funciones que el paquete tree provee est\u00e1n documentadas en el Manual del c\u00f3digo de soporte de COOL. Hay mucha informaci\u00f3n en este documento y ustedes necesitan saber la mayor\u00eda de esta informaci\u00f3n para crear un analizador sem\u00e1ntico funcional. Por favor lean esta asignaci\u00f3n detenida y cuidadosamente. A alto nivel, su analizador sem\u00e1ntico deber\u00eda de poder lograr las siguientes tareas: Ver todas las clases y construir un grafo de herencia. Verificar que el grafo est\u00e9 bien formado. Anotar el AST con tipos. Para cada clase: Atravesar el AST, reuniendo todas las declaraciones visibles en una tabla de s\u00edmbolos. Verificar que los tipos de cada expresi\u00f3n sean correctos. Esta lista de tareas no es exhaustiva, es responsabilidad de ustedes de implementar la especificaci\u00f3n descrita en el manual. 1. Archivos y Directorios \u00b6 Para empezar, creen el directorio PA3 junto a sus carpetas anteriores. ADENTRO de esta carpeta ejecuten el siguiente comando: make -f /usr/class/cc4/assignments/PA3/Makefile Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Adicionalmente tambi\u00e9n tienen que bajar el archivo SemantErrors.java : Descargar SemantErrors Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool-tree.java : Este archivo contiene definiciones de los nodos del AST y es el archivo principal de su implementaci\u00f3n. Ustedes van a necesitar agregar c\u00f3digo para su analizador sem\u00e1ntico en este archivo. El analizador sem\u00e1ntico es llamado utilizando el m\u00e9todo semant() de la clase programc . No modifiquen las declaraciones existentes. ClassTable.java : Esta clase es un placeholder para algunos m\u00e9todos \u00fatiles (incluyendo reporte de errores e inicializaci\u00f3n de las clases b\u00e1sicas). Pueden utilizar este archivo y mejorarlo para su analizador sem\u00e1ntico. TreeConstants.java : Este archivo define algunos AbstractSymbol \u00fatiles. good.cl y bad.cl : Estos archivos prueban algunas caracter\u00edsticas sem\u00e1nticas de COOL. Ustedes deber\u00edan de agregar tests que aseguren que good.cl tome en cuenta combinaciones sem\u00e1nticas legales (tantas como se puedan) y en bad.cl lo contrario, combinaciones sem\u00e1nticas ilegales. No es posible tomar en cuenta todas estas combinaciones en un solo archivo, ustedes son responsables de cubrir la mayor\u00eda de estas. Expliquen sus pruebas en estos archivos y pongan cualquier comentario en el archivo README. SemantErrors.java : Este archivo contiene m\u00e9todos que generan los errores correspondientes para el an\u00e1lisis sem\u00e1ntico, pueden agregar otros errores que talvez no est\u00e1n cubiertos en este archivo. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Agregue en este archivo cualquier explicaci\u00f3n adicional que considere relevante. 2. Atravesar el AST \u00b6 Como resultado de la asignaci\u00f3n 2, su parser construye un AST. El m\u00e9todo dump_with_types , definido en la mayor\u00eda de nodos del AST, ilustra como atravesar el AST y reunir informaci\u00f3n de \u00e9l. Esto refleja un estilo de algoritmo recursivo para atravesar el \u00e1rbol. Esto es bastante importante, porque es una manera natural de estructurar varias operaciones en un AST. Su tarea de programaci\u00f3n en esta asignaci\u00f3n es, primero atravesar el \u00e1rbol, segundo manejar varias piezas de informaci\u00f3n que ustedes reunan del \u00e1rbol y tercero utilizar esa informaci\u00f3n para forzar la sem\u00e1ntica de COOL. Atravesar el \u00e1rbol una vez se le suele llamar una \"pasada\". Ustedes probablemente deban realizar tres pasadas sobre el AST para verificar todo. Ustedes van a necesitar agregar informaci\u00f3n adicional en los nodos del AST. Para hacer esto, van a necesitar editar el archivo cool-tree.java directamente. 3. Herencia \u00b6 Se recomienda que empiece su semantic construyendo un grafo que muestre las relaciones de herencia entre clases. En este grafo no deber\u00edan existir ciclos, pues esto le causar\u00eda muchos problemas m\u00e1s adelante cuando necesite obtener los features de alguna clase padre. Adicionalmente, COOL tiene restricciones en heredar de las clases b\u00e1sicas (vean el manual). Es tambi\u00e9n un error si la clase A hereda de la clase B pero la clase B no est\u00e1 definida. El esqueleto del proyecto incluye definiciones apropiadas de todas las clases b\u00e1sicas. Ustedes van a necesitar incorporar estas clases en el grafo de herencia. Les sugerimos que dividan su an\u00e1lisis sem\u00e1ntico en varios peque\u00f1os componentes. Comience creando un grafo de herencia y revise que este est\u00e9 bien definido, si hubiera un error, det\u00e9ngase y no contin\u00fae analizando el resto de los errores. Cuando esta estructura ya est\u00e9 completa y bien revisada, ya podr\u00e1 usarla para cualquier otra comprobaci\u00f3n que necesite m\u00e1s adelante. 4. Scopes y Variables \u00b6 Una gran porci\u00f3n del an\u00e1lisis sem\u00e1ntico es manejar los nombres de variables. El problema en espec\u00edfico es determinar qu\u00e9 declaraci\u00f3n est\u00e1 activa para cada uso de una variable o identificador, especialmente cuando un nombre de variable puede ser reutilizado. Por ejemplo, si i es declarado en dos expresiones let , una anidada dentro de la otra, entonces en cualquier momento que i sea referenciado la sem\u00e1ntica de COOL especifica que declaraci\u00f3n de estas dos est\u00e1 activa. Es trabajo del analizador sem\u00e1ntico guardar un registro de que declaraci\u00f3n hace referencia a una variable. Como se discuti\u00f3 en clase, una tabla de s\u00edmbolos es una estructura de datos conveniente para manejar nombres de variable y scopes. Ustedes pueden utilizar nuestra implementaci\u00f3n de una tabla de s\u00edmbolos para este proyecto. Nuestra implementaci\u00f3n provee m\u00e9todos para entrar, salir y aumentar los scopes como sea posible. Ustedes son libres de implementar su propia tabla de s\u00edmbolos tambi\u00e9n, es como ustedes prefieran. Adem\u00e1s del identificador self , que est\u00e1 implicitamente definido en cada clase, hay cuatro maneras que un objeto pueda ser introducido en COOL: Definiciones de atributos de clase. Par\u00e1metros formales en los m\u00e9todos. Expresiones let. Los branches de un case. Adicionalmente a los nombres de variables, hay nombres de m\u00e9todos y nombres de clases. Es un error utilizar cualquier nombre que no tenga una declaraci\u00f3n correspondiente. En este caso, sin embargo, el analizador sem\u00e1ntico no deber\u00eda de abortar la compilaci\u00f3n despu\u00e9s de descubrir este tipo de errores. Recuerden: ni los m\u00e9todos, ni las clases, ni los atributos necesitan ser declarados antes de ser utilizados. Por ejemplo: es posible que dentro del m\u00e9todo main se mande a llamar al m\u00e9todo foo y este m\u00e9todo est\u00e9 declarado m\u00e1s abajo en el archivo. Piensen c\u00f3mo esto afecta su an\u00e1lisis sem\u00e1ntico. 5. Verificaci\u00f3n de Tipos \u00b6 La verificaci\u00f3n de tipos es otra funci\u00f3n principal del analizador sem\u00e1ntico. El analizador sem\u00e1ntico tiene que verificar que tipos v\u00e1lidos sean declarados en donde sea requerido. Por ejemplo, los tipos de retorno de los m\u00e9todos tienen que ser declarados. Utilizando esta informaci\u00f3n, el analizador sem\u00e1ntico tiene que verificar tambi\u00e9n que la expresi\u00f3n dentro del m\u00e9todo tiene un tipo v\u00e1lido de acuerdo a las reglas de inferencia. Las reglas de inferencia est\u00e1n detalladas en el manual de referencia de COOL y tambi\u00e9n fueron explicadas en clase. Un problema dif\u00edcil es qu\u00e9 hacer si una expresi\u00f3n no tiene un tipo v\u00e1lido de acuerdo a las reglas. Primero, un error se deber\u00eda de imprimir con el n\u00famero de l\u00ednea y una descripci\u00f3n de que fue lo que estuvo mal. Errores Utilicen la clase de ayuda SemantErrors.java para imprimir los errores necesarios durante el an\u00e1lisis sem\u00e1ntico. Es relativamente f\u00e1cil dar mensajes de error coherentes, porque generalmente es obvio que error es. Nosotros esperamos que ustedes den mensajes de error informativos de acuerdo a lo que se encuentra en SemantErrors.java . Segundo, el analizador sem\u00e1ntico tiene que tratar de recuperarse y continuar. Nosotros s\u00ed esperamos que su analizador sem\u00e1ntico se recupere, pero no esperamos que evite errores en cascada. Un mecanismo de recuperaci\u00f3n simple es asignar el tipo Object a cualquier expresi\u00f3n que no se le pueda dar un tipo (nostros utilizamos esto en coolc). 6. Interfaz con Codegen \u00b6 Para que el analizador sem\u00e1ntico funcione correctamente con el resto del compilador de COOL, algunas precauciones tienen que tomarse en cuenta para que la interfaz con el generador de c\u00f3digo sea correcta. Nostros hemos adoptado una simple e ingenua interfaz para evitar reducir sus impulsos de creatividad en el an\u00e1lisis sem\u00e1ntico. Sin embargo, una cosa m\u00e1s tienen que hacer. Para cada nodo expression, su campo de tipo tiene que ser cambiado al AbstractSymbol que fue inferido por su analizador sem\u00e1ntico. Este AbstractSymbol deber\u00eda de ser el resultado de utilizar el m\u00e9todo addString en fases anteriores en la tabla idtable . La expresi\u00f3n especial no_expr tiene que ser asignada con el tipo No_type que es un s\u00edmbolo predefinido en el esqueleto del proyecto. 7. Salida Esperada \u00b6 Para programas que est\u00e9n incorrectos sem\u00e1nticamente, la salida de su analizador sem\u00e1ntico son mensajes de error. Nosotros esperamos de ustedes que se puedan recuperar de la mayor\u00eda de errores exceptuando errores de herencia. Tambi\u00e9n se espera de ustedes que produzcan mensajes de error informativos de acuerdo a SemantErrors.java vean este archivo para imprimir los errores. Asumiendo que la herencia est\u00e1 bien formada, el analizador sem\u00e1ntico deber\u00eda de capturar y reportar todos los errores sem\u00e1nticos en el programa. Para programas que est\u00e9n correctos sem\u00e1nticamente, la salida es un AST anotado. Ustedes van a ser calificados si su analizador sem\u00e1ntico anota correctamente el AST con tipos y cuando funcione correctamente con el generador de c\u00f3digo de coolc. 8. Probando el Analizador \u00b6 Van a necesitar un analizador l\u00e9xico y sint\u00e1ctico para probar su analizador sem\u00e1ntico. Pueden utilizar sus implementaciones a estas fases o utilizar las que nosotros les proveemos. Por defecto, las que nosotros les proveemos son utilizadas, para cambiar este comportamiento tienen que cambiar los archivos lexer y parser con sus propias implementaciones. De todas maneras el autograder principal de este proyecto utiliza los analizadores del compilador de COOL coolc . Ustedes pueden probar su analizador sem\u00e1ntico utilizando ./mysemant , que es un shell script que \"pega\" el analizador con las fases anteriores. Noten que ./mysemant puede tomar una bandera -s para depurar el analizador. Utilizar esta bandera hace que la bandera debug se cambie a verdadero, esta est\u00e1 definida en el archivo Flags.java . Agregar el c\u00f3digo que hace la depuraci\u00f3n es su responsabilidad. Vean el README para m\u00e1s detalles e informaci\u00f3n. Una vez que est\u00e9n bastante confiados de que su analizador est\u00e1 funcionando correctamente, intenten ejecutar ./mycoolc para invocar su analizador con todas las fases del compilador. Ustedes deber\u00edan de probar este compilador en archivos de entrada buenos y malos, para ver si funciona correctamente. Recuerden, los bugs en el an\u00e1lisis sem\u00e1ntico pueden manifestarse en el c\u00f3digo generado o solo cuando el programa compilado sea ejecutado con spim. 9. Observaciones \u00b6 El an\u00e1lisis sem\u00e1ntico es la fase m\u00e1s larga y compleja hasta el momento del compilador. Nuestra soluci\u00f3n es de aproximadamente 1000 l\u00edneas de c\u00f3digo de Java bien documentado. Ustedes van a encontrar esta asignaci\u00f3n f\u00e1cil si se toman un tiempo para dise\u00f1ar el verificador de tipos antes de programar. Preg\u00fantense a ustedes mismos lo siguiente: \u00bfQu\u00e9 requerimientos necesito verificar? \u00bfCu\u00e1ndo necesito verificar un requerimiento? \u00bfCu\u00e1ndo la informaci\u00f3n es requerida para verificar un requerimiento? \u00bfD\u00f3nde est\u00e1 la informaci\u00f3n que necesito para verificar un requerimiento? 10. Autograder \u00b6 Ustedes deber\u00edan de descargar el siguiente script en el mismo directorio donde tienen sus archivos de la tercera fase, y volverlo ejecutable: wget https://cc-4.github.io/cc4/pa3-grading.pl chmod +x pa3-grading.pl Luego lo ejecutan usando: ./pa3-grading.pl Esto califica su parser utilizando el analizador l\u00e9xico de coolc. Si ustedes quieren probar su parser utilizando su fase 1 y 2 descarguen el siguiente archivo, y vu\u00e9lvanlo ejecutable: wget https://cc-4.github.io/cc4/pa3-grading-all.sh chmod +x pa3-grading-all.sh Luego lo ejecutan usando: ./pa3-grading-all.sh Referencias \u00b6 The Tree Package - Javadoc del paquete Tree. The Cool Reference Manual - Manual de COOL. Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL.","title":"3: Semantic"},{"location":"projs/proj03/#analisis-semantico","text":"En est\u00e1 asignaci\u00f3n, ustedes van a implementar el an\u00e1lisis sem\u00e1ntico para COOL. Ustedes van a utilizar el AST construido por el parser para verificar si el programa est\u00e1 correcto sem\u00e1nticamente siguiendo la especificaci\u00f3n de COOL. Su analizador sem\u00e1ntico deber\u00eda de rechazar programas erroneos. Para programas que est\u00e9n correctos, deber\u00eda reunir informaci\u00f3n que va a ser utilizada por el generador de c\u00f3digo. La salida del analizador sem\u00e1ntico va a ser un AST anotado utilizado por su generador de c\u00f3digo. En esta asignaci\u00f3n tiene m\u00e1s libertad para tomar decisiones de dise\u00f1o que en las \u00faltimas dos asignaciones. Su semantic va a ser correcto si puede verificar programas reflejando la especificaci\u00f3n. No hay una sola soluci\u00f3n para esta asignaci\u00f3n, pero si hay muchas malas maneras de implementarla. Hay un n\u00famero de practicas est\u00e1ndar que creemos que hacen la vida m\u00e1s f\u00e1cil, y les vamos a tratar de inculcar estas pr\u00e1cticas a ustedes. Sin embargo, lo que ustedes hagan es su responsabilidad, cualquier cosa que ustedes decidan hacer, est\u00e9n preparados para justificarla y explicarla. Ustedes van a necesitar referirse a las reglas de inferencia de tipos descritas en el manual de referencia de COOL. Ustedes tambi\u00e9n van a necesitar agregar m\u00e9todos y atributos a los nodos del AST para esta fase. Las funciones que el paquete tree provee est\u00e1n documentadas en el Manual del c\u00f3digo de soporte de COOL. Hay mucha informaci\u00f3n en este documento y ustedes necesitan saber la mayor\u00eda de esta informaci\u00f3n para crear un analizador sem\u00e1ntico funcional. Por favor lean esta asignaci\u00f3n detenida y cuidadosamente. A alto nivel, su analizador sem\u00e1ntico deber\u00eda de poder lograr las siguientes tareas: Ver todas las clases y construir un grafo de herencia. Verificar que el grafo est\u00e9 bien formado. Anotar el AST con tipos. Para cada clase: Atravesar el AST, reuniendo todas las declaraciones visibles en una tabla de s\u00edmbolos. Verificar que los tipos de cada expresi\u00f3n sean correctos. Esta lista de tareas no es exhaustiva, es responsabilidad de ustedes de implementar la especificaci\u00f3n descrita en el manual.","title":"An\u00e1lisis Sem\u00e1ntico"},{"location":"projs/proj03/#1-archivos-y-directorios","text":"Para empezar, creen el directorio PA3 junto a sus carpetas anteriores. ADENTRO de esta carpeta ejecuten el siguiente comando: make -f /usr/class/cc4/assignments/PA3/Makefile Este comando va a copiar un n\u00famero de archivos en su directorio que han creado. Algunos de los archivos que van a ser copiados van a ser de solo lectura (representando a estos con archivos que realmente son enlaces simb\u00f3licos hacia otros archivos). Ustedes no deber\u00edan de editar estos archivos. De hecho, si ustedes modifican estos archivos, van a encontrar imposible terminar y completar esta asignaci\u00f3n. Vean las instrucciones en el archivo README. Adicionalmente tambi\u00e9n tienen que bajar el archivo SemantErrors.java : Descargar SemantErrors Los \u00fanicos archivos que tienen permitido modificar para esta asignaci\u00f3n son: cool-tree.java : Este archivo contiene definiciones de los nodos del AST y es el archivo principal de su implementaci\u00f3n. Ustedes van a necesitar agregar c\u00f3digo para su analizador sem\u00e1ntico en este archivo. El analizador sem\u00e1ntico es llamado utilizando el m\u00e9todo semant() de la clase programc . No modifiquen las declaraciones existentes. ClassTable.java : Esta clase es un placeholder para algunos m\u00e9todos \u00fatiles (incluyendo reporte de errores e inicializaci\u00f3n de las clases b\u00e1sicas). Pueden utilizar este archivo y mejorarlo para su analizador sem\u00e1ntico. TreeConstants.java : Este archivo define algunos AbstractSymbol \u00fatiles. good.cl y bad.cl : Estos archivos prueban algunas caracter\u00edsticas sem\u00e1nticas de COOL. Ustedes deber\u00edan de agregar tests que aseguren que good.cl tome en cuenta combinaciones sem\u00e1nticas legales (tantas como se puedan) y en bad.cl lo contrario, combinaciones sem\u00e1nticas ilegales. No es posible tomar en cuenta todas estas combinaciones en un solo archivo, ustedes son responsables de cubrir la mayor\u00eda de estas. Expliquen sus pruebas en estos archivos y pongan cualquier comentario en el archivo README. SemantErrors.java : Este archivo contiene m\u00e9todos que generan los errores correspondientes para el an\u00e1lisis sem\u00e1ntico, pueden agregar otros errores que talvez no est\u00e1n cubiertos en este archivo. README : Este archivo contiene instrucciones detalladas para la asignaci\u00f3n, as\u00ed como tambi\u00e9n un n\u00famero de recomendaciones \u00fatiles. Agregue en este archivo cualquier explicaci\u00f3n adicional que considere relevante.","title":"1. Archivos y Directorios"},{"location":"projs/proj03/#2-atravesar-el-ast","text":"Como resultado de la asignaci\u00f3n 2, su parser construye un AST. El m\u00e9todo dump_with_types , definido en la mayor\u00eda de nodos del AST, ilustra como atravesar el AST y reunir informaci\u00f3n de \u00e9l. Esto refleja un estilo de algoritmo recursivo para atravesar el \u00e1rbol. Esto es bastante importante, porque es una manera natural de estructurar varias operaciones en un AST. Su tarea de programaci\u00f3n en esta asignaci\u00f3n es, primero atravesar el \u00e1rbol, segundo manejar varias piezas de informaci\u00f3n que ustedes reunan del \u00e1rbol y tercero utilizar esa informaci\u00f3n para forzar la sem\u00e1ntica de COOL. Atravesar el \u00e1rbol una vez se le suele llamar una \"pasada\". Ustedes probablemente deban realizar tres pasadas sobre el AST para verificar todo. Ustedes van a necesitar agregar informaci\u00f3n adicional en los nodos del AST. Para hacer esto, van a necesitar editar el archivo cool-tree.java directamente.","title":"2. Atravesar el AST"},{"location":"projs/proj03/#3-herencia","text":"Se recomienda que empiece su semantic construyendo un grafo que muestre las relaciones de herencia entre clases. En este grafo no deber\u00edan existir ciclos, pues esto le causar\u00eda muchos problemas m\u00e1s adelante cuando necesite obtener los features de alguna clase padre. Adicionalmente, COOL tiene restricciones en heredar de las clases b\u00e1sicas (vean el manual). Es tambi\u00e9n un error si la clase A hereda de la clase B pero la clase B no est\u00e1 definida. El esqueleto del proyecto incluye definiciones apropiadas de todas las clases b\u00e1sicas. Ustedes van a necesitar incorporar estas clases en el grafo de herencia. Les sugerimos que dividan su an\u00e1lisis sem\u00e1ntico en varios peque\u00f1os componentes. Comience creando un grafo de herencia y revise que este est\u00e9 bien definido, si hubiera un error, det\u00e9ngase y no contin\u00fae analizando el resto de los errores. Cuando esta estructura ya est\u00e9 completa y bien revisada, ya podr\u00e1 usarla para cualquier otra comprobaci\u00f3n que necesite m\u00e1s adelante.","title":"3. Herencia"},{"location":"projs/proj03/#4-scopes-y-variables","text":"Una gran porci\u00f3n del an\u00e1lisis sem\u00e1ntico es manejar los nombres de variables. El problema en espec\u00edfico es determinar qu\u00e9 declaraci\u00f3n est\u00e1 activa para cada uso de una variable o identificador, especialmente cuando un nombre de variable puede ser reutilizado. Por ejemplo, si i es declarado en dos expresiones let , una anidada dentro de la otra, entonces en cualquier momento que i sea referenciado la sem\u00e1ntica de COOL especifica que declaraci\u00f3n de estas dos est\u00e1 activa. Es trabajo del analizador sem\u00e1ntico guardar un registro de que declaraci\u00f3n hace referencia a una variable. Como se discuti\u00f3 en clase, una tabla de s\u00edmbolos es una estructura de datos conveniente para manejar nombres de variable y scopes. Ustedes pueden utilizar nuestra implementaci\u00f3n de una tabla de s\u00edmbolos para este proyecto. Nuestra implementaci\u00f3n provee m\u00e9todos para entrar, salir y aumentar los scopes como sea posible. Ustedes son libres de implementar su propia tabla de s\u00edmbolos tambi\u00e9n, es como ustedes prefieran. Adem\u00e1s del identificador self , que est\u00e1 implicitamente definido en cada clase, hay cuatro maneras que un objeto pueda ser introducido en COOL: Definiciones de atributos de clase. Par\u00e1metros formales en los m\u00e9todos. Expresiones let. Los branches de un case. Adicionalmente a los nombres de variables, hay nombres de m\u00e9todos y nombres de clases. Es un error utilizar cualquier nombre que no tenga una declaraci\u00f3n correspondiente. En este caso, sin embargo, el analizador sem\u00e1ntico no deber\u00eda de abortar la compilaci\u00f3n despu\u00e9s de descubrir este tipo de errores. Recuerden: ni los m\u00e9todos, ni las clases, ni los atributos necesitan ser declarados antes de ser utilizados. Por ejemplo: es posible que dentro del m\u00e9todo main se mande a llamar al m\u00e9todo foo y este m\u00e9todo est\u00e9 declarado m\u00e1s abajo en el archivo. Piensen c\u00f3mo esto afecta su an\u00e1lisis sem\u00e1ntico.","title":"4. Scopes y Variables"},{"location":"projs/proj03/#5-verificacion-de-tipos","text":"La verificaci\u00f3n de tipos es otra funci\u00f3n principal del analizador sem\u00e1ntico. El analizador sem\u00e1ntico tiene que verificar que tipos v\u00e1lidos sean declarados en donde sea requerido. Por ejemplo, los tipos de retorno de los m\u00e9todos tienen que ser declarados. Utilizando esta informaci\u00f3n, el analizador sem\u00e1ntico tiene que verificar tambi\u00e9n que la expresi\u00f3n dentro del m\u00e9todo tiene un tipo v\u00e1lido de acuerdo a las reglas de inferencia. Las reglas de inferencia est\u00e1n detalladas en el manual de referencia de COOL y tambi\u00e9n fueron explicadas en clase. Un problema dif\u00edcil es qu\u00e9 hacer si una expresi\u00f3n no tiene un tipo v\u00e1lido de acuerdo a las reglas. Primero, un error se deber\u00eda de imprimir con el n\u00famero de l\u00ednea y una descripci\u00f3n de que fue lo que estuvo mal. Errores Utilicen la clase de ayuda SemantErrors.java para imprimir los errores necesarios durante el an\u00e1lisis sem\u00e1ntico. Es relativamente f\u00e1cil dar mensajes de error coherentes, porque generalmente es obvio que error es. Nosotros esperamos que ustedes den mensajes de error informativos de acuerdo a lo que se encuentra en SemantErrors.java . Segundo, el analizador sem\u00e1ntico tiene que tratar de recuperarse y continuar. Nosotros s\u00ed esperamos que su analizador sem\u00e1ntico se recupere, pero no esperamos que evite errores en cascada. Un mecanismo de recuperaci\u00f3n simple es asignar el tipo Object a cualquier expresi\u00f3n que no se le pueda dar un tipo (nostros utilizamos esto en coolc).","title":"5. Verificaci\u00f3n de Tipos"},{"location":"projs/proj03/#6-interfaz-con-codegen","text":"Para que el analizador sem\u00e1ntico funcione correctamente con el resto del compilador de COOL, algunas precauciones tienen que tomarse en cuenta para que la interfaz con el generador de c\u00f3digo sea correcta. Nostros hemos adoptado una simple e ingenua interfaz para evitar reducir sus impulsos de creatividad en el an\u00e1lisis sem\u00e1ntico. Sin embargo, una cosa m\u00e1s tienen que hacer. Para cada nodo expression, su campo de tipo tiene que ser cambiado al AbstractSymbol que fue inferido por su analizador sem\u00e1ntico. Este AbstractSymbol deber\u00eda de ser el resultado de utilizar el m\u00e9todo addString en fases anteriores en la tabla idtable . La expresi\u00f3n especial no_expr tiene que ser asignada con el tipo No_type que es un s\u00edmbolo predefinido en el esqueleto del proyecto.","title":"6. Interfaz con Codegen"},{"location":"projs/proj03/#7-salida-esperada","text":"Para programas que est\u00e9n incorrectos sem\u00e1nticamente, la salida de su analizador sem\u00e1ntico son mensajes de error. Nosotros esperamos de ustedes que se puedan recuperar de la mayor\u00eda de errores exceptuando errores de herencia. Tambi\u00e9n se espera de ustedes que produzcan mensajes de error informativos de acuerdo a SemantErrors.java vean este archivo para imprimir los errores. Asumiendo que la herencia est\u00e1 bien formada, el analizador sem\u00e1ntico deber\u00eda de capturar y reportar todos los errores sem\u00e1nticos en el programa. Para programas que est\u00e9n correctos sem\u00e1nticamente, la salida es un AST anotado. Ustedes van a ser calificados si su analizador sem\u00e1ntico anota correctamente el AST con tipos y cuando funcione correctamente con el generador de c\u00f3digo de coolc.","title":"7. Salida Esperada"},{"location":"projs/proj03/#8-probando-el-analizador","text":"Van a necesitar un analizador l\u00e9xico y sint\u00e1ctico para probar su analizador sem\u00e1ntico. Pueden utilizar sus implementaciones a estas fases o utilizar las que nosotros les proveemos. Por defecto, las que nosotros les proveemos son utilizadas, para cambiar este comportamiento tienen que cambiar los archivos lexer y parser con sus propias implementaciones. De todas maneras el autograder principal de este proyecto utiliza los analizadores del compilador de COOL coolc . Ustedes pueden probar su analizador sem\u00e1ntico utilizando ./mysemant , que es un shell script que \"pega\" el analizador con las fases anteriores. Noten que ./mysemant puede tomar una bandera -s para depurar el analizador. Utilizar esta bandera hace que la bandera debug se cambie a verdadero, esta est\u00e1 definida en el archivo Flags.java . Agregar el c\u00f3digo que hace la depuraci\u00f3n es su responsabilidad. Vean el README para m\u00e1s detalles e informaci\u00f3n. Una vez que est\u00e9n bastante confiados de que su analizador est\u00e1 funcionando correctamente, intenten ejecutar ./mycoolc para invocar su analizador con todas las fases del compilador. Ustedes deber\u00edan de probar este compilador en archivos de entrada buenos y malos, para ver si funciona correctamente. Recuerden, los bugs en el an\u00e1lisis sem\u00e1ntico pueden manifestarse en el c\u00f3digo generado o solo cuando el programa compilado sea ejecutado con spim.","title":"8. Probando el Analizador"},{"location":"projs/proj03/#9-observaciones","text":"El an\u00e1lisis sem\u00e1ntico es la fase m\u00e1s larga y compleja hasta el momento del compilador. Nuestra soluci\u00f3n es de aproximadamente 1000 l\u00edneas de c\u00f3digo de Java bien documentado. Ustedes van a encontrar esta asignaci\u00f3n f\u00e1cil si se toman un tiempo para dise\u00f1ar el verificador de tipos antes de programar. Preg\u00fantense a ustedes mismos lo siguiente: \u00bfQu\u00e9 requerimientos necesito verificar? \u00bfCu\u00e1ndo necesito verificar un requerimiento? \u00bfCu\u00e1ndo la informaci\u00f3n es requerida para verificar un requerimiento? \u00bfD\u00f3nde est\u00e1 la informaci\u00f3n que necesito para verificar un requerimiento?","title":"9. Observaciones"},{"location":"projs/proj03/#10-autograder","text":"Ustedes deber\u00edan de descargar el siguiente script en el mismo directorio donde tienen sus archivos de la tercera fase, y volverlo ejecutable: wget https://cc-4.github.io/cc4/pa3-grading.pl chmod +x pa3-grading.pl Luego lo ejecutan usando: ./pa3-grading.pl Esto califica su parser utilizando el analizador l\u00e9xico de coolc. Si ustedes quieren probar su parser utilizando su fase 1 y 2 descarguen el siguiente archivo, y vu\u00e9lvanlo ejecutable: wget https://cc-4.github.io/cc4/pa3-grading-all.sh chmod +x pa3-grading-all.sh Luego lo ejecutan usando: ./pa3-grading-all.sh","title":"10. Autograder"},{"location":"projs/proj03/#referencias","text":"The Tree Package - Javadoc del paquete Tree. The Cool Reference Manual - Manual de COOL. Tour of the Cool Support Code - Manual del C\u00f3digo de Soporte de COOL.","title":"Referencias"},{"location":"projs/proj04/","text":"Generaci\u00f3n de c\u00f3digo \u00b6 1. Introducci\u00f3n \u00b6 En esta asignaci\u00f3n, ustedes van a implementar un generador de c\u00f3digo para COOL. Cuando hayan terminado satisfactoriamente esta parte, ustedes van a tener un compilador de COOL totalmente funcional. \u00daltima fase Esperamos que se den cuenta, que al finalizar esta fase, resolvieron un problema de ingenier\u00eda sustancialmente complejo. De ahora en adelante cualquier reto en cuesti\u00f3n de dise\u00f1o e implementaci\u00f3n deber\u00eda de ser por lo menos un poco m\u00e1s f\u00e1cil. El generador de c\u00f3digo hace uso del Abstract Syntax Tree (AST) construido durante la fase 2 del proyecto (Parser) y anotado en la fase 3 del proyecto (Semantic). Su generador de c\u00f3digo deber\u00eda de producir c\u00f3digo de ensamblador, que representa cualquier programa de COOL correcto para la arquitectura RISC-V. En esta fase (casi) no hay recuperaci\u00f3n de errores, en la generaci\u00f3n de c\u00f3digo ya podemos estar seguros de que cualquier programa erroneo de COOL ya ha sido detectado en las fases anteriores del compilador. Al igual que la anterior, esta fase tiene bastantes decisiones de dise\u00f1o que tomar. Nosotros les haremos varias recomendaciones, pero la decisi\u00f3n final de que estructuras utilizar, que algoritmos implementar, etc. es suya. Se recomienda que la estructura de esta fase sea lo m\u00e1s parecida posible a la anterior. Generar c\u00f3digo v\u00e1lido \u00b6 En varios momentos quiz\u00e1s mencionemos \"generar c\u00f3digo v\u00e1lido\" o \"generar c\u00f3digo equivalente\". Su c\u00f3digo no necesita ser 100% igual al generado por coolc-rv, sin embargo s\u00ed debe funcionar igual. Recuerde que el autograder se basa en prints, entonces al final de cuentas los programas que usted compile con su proyecto deber\u00edan imprimir exactamente lo mismo que los compilados con coolc-rv. 2. Ambiente \u00b6 Debe tener instalado coolc-rv y jupitercl, si no los tiene, revise la seccion de Instalacion de Material. Para comprobar que todo este instalado correctamente, compilen y corran un programa simple de COOL: class Main inherits IO { main(): Object { out_string(\"hello world\") }; }; Utilizando coolc-rv compilamos: coolc-rv main.cl Y al ejecutar veremos un resultado como este: jupitercl main.s hello world COOL program successfully executed Jupiter: exit(0) jupitercl Noten que se est\u00e1 haciendo uso del comando jupitercl , este a diferencia del comando jupiter carga autom\u00e1ticamente el runtime system de COOL. 3. Archivos y directorios \u00b6 A diferencia de las fases anteriores no comenzaremos con un make, sino que obtendremos nuestros archivos base desde este repositorio: git clone https://github.com/CC-4/PA4.git Casi todos estos archivos han sido explicados en las fases anteriores del proyecto. Esta es una lista de los archivos que ustedes tal vez quieran modificar. CgenClassTable.java y CgenNode.java : Estos archivos proveen una implementaci\u00f3n del grafo de herencia para el generador de c\u00f3digo. Ustedes van a tener que completar CgenClassTable para poder construir su generador de c\u00f3digo. Ustedes pueden utilizar el c\u00f3digo que se les provee o pueden reemplazarlo con el suyo o con el que hicieron en la fase anterior. StringSymbol.java , IntSymbol.java , y BoolConst.java : Estos archivos proveen soporte para las constantes de COOL. Ustedes van a tener que completar el m\u00e9todo para generar definiciones de estas constantes. cool-tree.java : Este archivo contiene la definici\u00f3n del los nodos del AST. Ustedes van a tener que a\u00f1adir rutinas de generaci\u00f3n de c\u00f3digo code(PrintStream) para todas las expresiones en este archivo. El generador de c\u00f3digo es mandado a llamar, empezando por code(PrintStream) que est\u00e1 en la clase program . Ustedes tal vez quieran a\u00f1adir m\u00e1s m\u00e9todos, pero no modifiquen los m\u00e9todos ya existentes. TreeConstants.java : Como antes, este archivo define algunas constantes \u00fatiles, si\u00e9ntanse libres de a\u00f1adir las suyas y lo que quieran. CgenSupport.java : Este archivo contiene soporte general para generar c\u00f3digo. Van a encontrar una serie de funciones que se vuelven bastantes \u00fatiles para emitir instrucciones de RISC-V, aqu\u00ed est\u00e1 todo lo que necesitan. Pueden a\u00f1adir tambi\u00e9n las que ustedes quieran, pero no modifiquen nada de lo que ya est\u00e1 definido. example.cl : Este es su archivo de prueba para ver si lo que genera su generador de c\u00f3digo funciona correctamente. Hagan bastantes pruebas con este archivo como lo requieran. 4. Dise\u00f1o \u00b6 En consideraci\u00f3n a su dise\u00f1o, as\u00ed a grandes rasgos, su generador de c\u00f3digo deber\u00e1 hacer las siguientes tareas: Determinar y emitir c\u00f3digo para las constantes globales, como los prototipos de objeto. Determinar y emitir c\u00f3digo para las tablas globales, como la class_nameTab , la class_objTab y las dispatch tables. Determinar y emitir c\u00f3digo para las inicializaciones de atributos. Determinar y emitir c\u00f3digo para cada m\u00e9todo de cada clase. Hay varias maneras posibles de implementar un generador de c\u00f3digo. Una estrategia razonable es hacer el generador de c\u00f3digo en dos pasadas. La primera pasada decide el layout para cada clase, particularmente el offset en donde cada atributo es guardado en un objeto. Utilizando esta informaci\u00f3n, la segunda pasada recursivamente visita cada feature y genera c\u00f3digo de accumulator machine para cada expresi\u00f3n. Hay un n\u00famero de cosas que ustedes tienen que mantener en mente mientras dise\u00f1an su generador de c\u00f3digo: Su generador de c\u00f3digo tiene que funcionar correctamente con el Runtime de COOL ( runtime.s ) que se le provee. Debe entender el convenio utilizado, este se basa en dos principios: 1) Todo espacio que pedimos en el stack debemos devolverlo. 2) Los resultados que obtenemos van quedando en el acumulador ( a0 ). 4.1. Runtime Error Checking \u00b6 Al final del manual de COOL existe una lista de errores que pueden terminar un programa antes de lo esperado. De esta lista su generador de c\u00f3digo deber\u00eda de ser capaz de atrapar las primeras tres: dispatch on void , case on void y missing branch e imprimir un mensaje de error antes de abortar. Atrapar errores de substring out of range y heap overflow es responsabilidad del runtime system que est\u00e1 en runtime.s. Finalmente, la divisi\u00f3n entre 0 tambi\u00e9n es su responsabilidad, la maneja con _div_by_zero . 4.2. Garbage Collection \u00b6 Cerca del final del curso hablaremos sobre Garbage Collection. Si encuentra este t\u00e9rmino en alg\u00fan lugar ign\u00f3relo por el momento, probablemente es un remanente de cuando el proyecto se trabajaba en MIPS. Todo lo necesario para que el Garbage Collector funcione ya va implementado en el runtime que se le provee. Usted solo debe encargarse que sus objetos tengan la forma correcta (tag, size, pointer, attr). 5. Probando su Codegen \u00b6 Van a necesitar un analizador l\u00e9xico, sint\u00e1ctico y sem\u00e1ntico para probar su generador de c\u00f3digo. Pueden utilizar sus implementaciones a estas fases o utilizar las que nosotros les proveemos. Por defecto, las que nosotros les proveemos son utilizadas, para cambiar este comportamiento tienen que cambiar los archivos lexer, parser y semant con sus propias implementaciones. Ustedes van a tener que correr su generador de c\u00f3digo utilizando ./mycoolc , que es un shell script que pega el generador de c\u00f3digo que ustedes implementaron con el resto de fases. Tomen en cuenta que ./mycoolc puede tomar una bandera -c para depurar el generador de c\u00f3digo, utilizando esta bandera, se cambia la bandera debug a verdadero, que est\u00e1 en Flags.java . Agregar c\u00f3digo para producir informaci\u00f3n de depuraci\u00f3n es tarea de ustedes si quieren utilizarlo. 5.1. Jupiter \u00b6 El ejecutable de Jupiter jupitercl es el simulador para la arquitectura RISC-V en donde pueden probar su generador de c\u00f3digo. Tiene muchas funcionalidades que les permite examinar el estado de la memoria, s\u00edmbolos globales y locales, registros, etc del programa. Ustedes tambi\u00e9n pueden poner breakpoints y hacer step de su programa. Para poder utilizar el debugger de Jupiter ustedes pueden hacer lo siguiente: jupitercl -g <archivo.s> >>> help Available commands: [General Commands] help/? - show this help message exit/quit/q - exit the simulator and debugger ! - execute previous command [Display] rvi - print all RVI registers rvi <reg> - print RVI register reg rvf - print all RVF registers rvf <reg> - print RVF register reg memory <addr> - print 12 x 4 cells of memory starting at the given address memory <addr> <rows> - print rows x 4 cells of memory starting at the given address globals - print global symbol table locals - print local symbol tables [Execution Control] step/s - continue until another instruction reached backstep/b - back to the previous instruction continue/c - continue running reset - reset [Breakpoints] break <addr> - set a breakpoint at the given address clear - delete all breakpoints delete <addr> - delete breakpoint at the given address list - show defined breakpoints 6. Autograder \u00b6 Descargue el autograder en la misma carpeta donde tiene su cuarta fase: wget https://cc-4.github.io/cc4/pa4-grading.py chmod +x pa4-grading.py Luego ejecute el siguiente comando: ./pa4-grading.py Si quiere probar todas sus fases juntas, utilice el siguiente autograder: wget https://cc-4.github.io/cc4/pa4-grading-all.sh chmod +x pa4-grading-all.sh Luego ejecute el siguiente comando: ./pa4-grading-all.sh Si no est\u00e1 conforme con la nota del autograder, es su responsabilidad elaborar y presentar testcases propios al momento de la calificaci\u00f3n. Estos testcases deben mostrar de qu\u00e9 es capaz su Codegen. Realizarlos no le garantiza que tendr\u00e1 la misma nota que alguien a qui\u00e9n el autograder s\u00ed le funcion\u00f3, pero le ayudar\u00e1 a quitarse el cero.","title":"4: Codegen"},{"location":"projs/proj04/#generacion-de-codigo","text":"","title":"Generaci\u00f3n de c\u00f3digo"},{"location":"projs/proj04/#1-introduccion","text":"En esta asignaci\u00f3n, ustedes van a implementar un generador de c\u00f3digo para COOL. Cuando hayan terminado satisfactoriamente esta parte, ustedes van a tener un compilador de COOL totalmente funcional. \u00daltima fase Esperamos que se den cuenta, que al finalizar esta fase, resolvieron un problema de ingenier\u00eda sustancialmente complejo. De ahora en adelante cualquier reto en cuesti\u00f3n de dise\u00f1o e implementaci\u00f3n deber\u00eda de ser por lo menos un poco m\u00e1s f\u00e1cil. El generador de c\u00f3digo hace uso del Abstract Syntax Tree (AST) construido durante la fase 2 del proyecto (Parser) y anotado en la fase 3 del proyecto (Semantic). Su generador de c\u00f3digo deber\u00eda de producir c\u00f3digo de ensamblador, que representa cualquier programa de COOL correcto para la arquitectura RISC-V. En esta fase (casi) no hay recuperaci\u00f3n de errores, en la generaci\u00f3n de c\u00f3digo ya podemos estar seguros de que cualquier programa erroneo de COOL ya ha sido detectado en las fases anteriores del compilador. Al igual que la anterior, esta fase tiene bastantes decisiones de dise\u00f1o que tomar. Nosotros les haremos varias recomendaciones, pero la decisi\u00f3n final de que estructuras utilizar, que algoritmos implementar, etc. es suya. Se recomienda que la estructura de esta fase sea lo m\u00e1s parecida posible a la anterior.","title":"1. Introducci\u00f3n"},{"location":"projs/proj04/#generar-codigo-valido","text":"En varios momentos quiz\u00e1s mencionemos \"generar c\u00f3digo v\u00e1lido\" o \"generar c\u00f3digo equivalente\". Su c\u00f3digo no necesita ser 100% igual al generado por coolc-rv, sin embargo s\u00ed debe funcionar igual. Recuerde que el autograder se basa en prints, entonces al final de cuentas los programas que usted compile con su proyecto deber\u00edan imprimir exactamente lo mismo que los compilados con coolc-rv.","title":"Generar c\u00f3digo v\u00e1lido"},{"location":"projs/proj04/#2-ambiente","text":"Debe tener instalado coolc-rv y jupitercl, si no los tiene, revise la seccion de Instalacion de Material. Para comprobar que todo este instalado correctamente, compilen y corran un programa simple de COOL: class Main inherits IO { main(): Object { out_string(\"hello world\") }; }; Utilizando coolc-rv compilamos: coolc-rv main.cl Y al ejecutar veremos un resultado como este: jupitercl main.s hello world COOL program successfully executed Jupiter: exit(0) jupitercl Noten que se est\u00e1 haciendo uso del comando jupitercl , este a diferencia del comando jupiter carga autom\u00e1ticamente el runtime system de COOL.","title":"2. Ambiente"},{"location":"projs/proj04/#3-archivos-y-directorios","text":"A diferencia de las fases anteriores no comenzaremos con un make, sino que obtendremos nuestros archivos base desde este repositorio: git clone https://github.com/CC-4/PA4.git Casi todos estos archivos han sido explicados en las fases anteriores del proyecto. Esta es una lista de los archivos que ustedes tal vez quieran modificar. CgenClassTable.java y CgenNode.java : Estos archivos proveen una implementaci\u00f3n del grafo de herencia para el generador de c\u00f3digo. Ustedes van a tener que completar CgenClassTable para poder construir su generador de c\u00f3digo. Ustedes pueden utilizar el c\u00f3digo que se les provee o pueden reemplazarlo con el suyo o con el que hicieron en la fase anterior. StringSymbol.java , IntSymbol.java , y BoolConst.java : Estos archivos proveen soporte para las constantes de COOL. Ustedes van a tener que completar el m\u00e9todo para generar definiciones de estas constantes. cool-tree.java : Este archivo contiene la definici\u00f3n del los nodos del AST. Ustedes van a tener que a\u00f1adir rutinas de generaci\u00f3n de c\u00f3digo code(PrintStream) para todas las expresiones en este archivo. El generador de c\u00f3digo es mandado a llamar, empezando por code(PrintStream) que est\u00e1 en la clase program . Ustedes tal vez quieran a\u00f1adir m\u00e1s m\u00e9todos, pero no modifiquen los m\u00e9todos ya existentes. TreeConstants.java : Como antes, este archivo define algunas constantes \u00fatiles, si\u00e9ntanse libres de a\u00f1adir las suyas y lo que quieran. CgenSupport.java : Este archivo contiene soporte general para generar c\u00f3digo. Van a encontrar una serie de funciones que se vuelven bastantes \u00fatiles para emitir instrucciones de RISC-V, aqu\u00ed est\u00e1 todo lo que necesitan. Pueden a\u00f1adir tambi\u00e9n las que ustedes quieran, pero no modifiquen nada de lo que ya est\u00e1 definido. example.cl : Este es su archivo de prueba para ver si lo que genera su generador de c\u00f3digo funciona correctamente. Hagan bastantes pruebas con este archivo como lo requieran.","title":"3. Archivos y directorios"},{"location":"projs/proj04/#4-diseno","text":"En consideraci\u00f3n a su dise\u00f1o, as\u00ed a grandes rasgos, su generador de c\u00f3digo deber\u00e1 hacer las siguientes tareas: Determinar y emitir c\u00f3digo para las constantes globales, como los prototipos de objeto. Determinar y emitir c\u00f3digo para las tablas globales, como la class_nameTab , la class_objTab y las dispatch tables. Determinar y emitir c\u00f3digo para las inicializaciones de atributos. Determinar y emitir c\u00f3digo para cada m\u00e9todo de cada clase. Hay varias maneras posibles de implementar un generador de c\u00f3digo. Una estrategia razonable es hacer el generador de c\u00f3digo en dos pasadas. La primera pasada decide el layout para cada clase, particularmente el offset en donde cada atributo es guardado en un objeto. Utilizando esta informaci\u00f3n, la segunda pasada recursivamente visita cada feature y genera c\u00f3digo de accumulator machine para cada expresi\u00f3n. Hay un n\u00famero de cosas que ustedes tienen que mantener en mente mientras dise\u00f1an su generador de c\u00f3digo: Su generador de c\u00f3digo tiene que funcionar correctamente con el Runtime de COOL ( runtime.s ) que se le provee. Debe entender el convenio utilizado, este se basa en dos principios: 1) Todo espacio que pedimos en el stack debemos devolverlo. 2) Los resultados que obtenemos van quedando en el acumulador ( a0 ).","title":"4. Dise\u00f1o"},{"location":"projs/proj04/#41-runtime-error-checking","text":"Al final del manual de COOL existe una lista de errores que pueden terminar un programa antes de lo esperado. De esta lista su generador de c\u00f3digo deber\u00eda de ser capaz de atrapar las primeras tres: dispatch on void , case on void y missing branch e imprimir un mensaje de error antes de abortar. Atrapar errores de substring out of range y heap overflow es responsabilidad del runtime system que est\u00e1 en runtime.s. Finalmente, la divisi\u00f3n entre 0 tambi\u00e9n es su responsabilidad, la maneja con _div_by_zero .","title":"4.1. Runtime Error Checking"},{"location":"projs/proj04/#42-garbage-collection","text":"Cerca del final del curso hablaremos sobre Garbage Collection. Si encuentra este t\u00e9rmino en alg\u00fan lugar ign\u00f3relo por el momento, probablemente es un remanente de cuando el proyecto se trabajaba en MIPS. Todo lo necesario para que el Garbage Collector funcione ya va implementado en el runtime que se le provee. Usted solo debe encargarse que sus objetos tengan la forma correcta (tag, size, pointer, attr).","title":"4.2. Garbage Collection"},{"location":"projs/proj04/#5-probando-su-codegen","text":"Van a necesitar un analizador l\u00e9xico, sint\u00e1ctico y sem\u00e1ntico para probar su generador de c\u00f3digo. Pueden utilizar sus implementaciones a estas fases o utilizar las que nosotros les proveemos. Por defecto, las que nosotros les proveemos son utilizadas, para cambiar este comportamiento tienen que cambiar los archivos lexer, parser y semant con sus propias implementaciones. Ustedes van a tener que correr su generador de c\u00f3digo utilizando ./mycoolc , que es un shell script que pega el generador de c\u00f3digo que ustedes implementaron con el resto de fases. Tomen en cuenta que ./mycoolc puede tomar una bandera -c para depurar el generador de c\u00f3digo, utilizando esta bandera, se cambia la bandera debug a verdadero, que est\u00e1 en Flags.java . Agregar c\u00f3digo para producir informaci\u00f3n de depuraci\u00f3n es tarea de ustedes si quieren utilizarlo.","title":"5. Probando su Codegen"},{"location":"projs/proj04/#51-jupiter","text":"El ejecutable de Jupiter jupitercl es el simulador para la arquitectura RISC-V en donde pueden probar su generador de c\u00f3digo. Tiene muchas funcionalidades que les permite examinar el estado de la memoria, s\u00edmbolos globales y locales, registros, etc del programa. Ustedes tambi\u00e9n pueden poner breakpoints y hacer step de su programa. Para poder utilizar el debugger de Jupiter ustedes pueden hacer lo siguiente: jupitercl -g <archivo.s> >>> help Available commands: [General Commands] help/? - show this help message exit/quit/q - exit the simulator and debugger ! - execute previous command [Display] rvi - print all RVI registers rvi <reg> - print RVI register reg rvf - print all RVF registers rvf <reg> - print RVF register reg memory <addr> - print 12 x 4 cells of memory starting at the given address memory <addr> <rows> - print rows x 4 cells of memory starting at the given address globals - print global symbol table locals - print local symbol tables [Execution Control] step/s - continue until another instruction reached backstep/b - back to the previous instruction continue/c - continue running reset - reset [Breakpoints] break <addr> - set a breakpoint at the given address clear - delete all breakpoints delete <addr> - delete breakpoint at the given address list - show defined breakpoints","title":"5.1. Jupiter"},{"location":"projs/proj04/#6-autograder","text":"Descargue el autograder en la misma carpeta donde tiene su cuarta fase: wget https://cc-4.github.io/cc4/pa4-grading.py chmod +x pa4-grading.py Luego ejecute el siguiente comando: ./pa4-grading.py Si quiere probar todas sus fases juntas, utilice el siguiente autograder: wget https://cc-4.github.io/cc4/pa4-grading-all.sh chmod +x pa4-grading-all.sh Luego ejecute el siguiente comando: ./pa4-grading-all.sh Si no est\u00e1 conforme con la nota del autograder, es su responsabilidad elaborar y presentar testcases propios al momento de la calificaci\u00f3n. Estos testcases deben mostrar de qu\u00e9 es capaz su Codegen. Realizarlos no le garantiza que tendr\u00e1 la misma nota que alguien a qui\u00e9n el autograder s\u00ed le funcion\u00f3, pero le ayudar\u00e1 a quitarse el cero.","title":"6. Autograder"}]}